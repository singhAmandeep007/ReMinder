{"version":3,"file":"static/js/806.0c6f53c9.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/checkPrivateRedeclaration.js","../node_modules/@babel/runtime/helpers/esm/assertClassBrand.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js","../node_modules/@open-draft/until/src/until.ts","../node_modules/msw/src/core/utils/executeHandlers.ts","../node_modules/msw/src/core/utils/handleRequest.ts","../node_modules/msw/src/core/utils/request/onUnhandledRequest.ts","../node_modules/msw/src/core/utils/request/readResponseCookies.ts","../node_modules/msw/src/core/utils/internal/Disposable.ts","../node_modules/msw/src/core/SetupApi.ts","../node_modules/msw/src/core/utils/internal/pipeEvents.ts","../node_modules/msw/src/core/utils/internal/toReadonlyArray.ts","../node_modules/msw/src/core/utils/internal/isObject.ts","../node_modules/msw/src/core/utils/internal/mergeRight.ts","../node_modules/msw/node_modules/.pnpm/outvariant@1.4.2/node_modules/outvariant/src/format.ts","../node_modules/msw/node_modules/.pnpm/outvariant@1.4.2/node_modules/outvariant/src/invariant.ts","../node_modules/msw/node_modules/.pnpm/is-node-process@1.2.0/node_modules/is-node-process/src/index.ts","../node_modules/msw/node_modules/.pnpm/@open-draft+until@2.1.0/node_modules/@open-draft/until/src/until.ts","../node_modules/msw/src/browser/setupWorker/start/utils/getWorkerByRegistration.ts","../node_modules/msw/src/browser/setupWorker/start/utils/getWorkerInstance.ts","../node_modules/msw/src/browser/utils/getAbsoluteWorkerUrl.ts","../node_modules/msw/src/browser/setupWorker/start/utils/printStartMessage.ts","../node_modules/msw/src/browser/setupWorker/start/utils/createMessageChannel.ts","../node_modules/msw/src/browser/utils/pruneGetRequestBody.ts","../node_modules/msw/src/browser/setupWorker/start/createRequestListener.ts","../node_modules/msw/src/browser/utils/parseWorkerRequest.ts","../node_modules/msw/src/core/utils/toResponseInit.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/utils/bufferUtils.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/utils/responseUtils.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/glossary.ts","../node_modules/msw/node_modules/.pnpm/@open-draft+logger@0.3.0/node_modules/@open-draft/logger/lib/index.mjs","../node_modules/msw/node_modules/.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/src/MemoryLeakError.ts","../node_modules/msw/node_modules/.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/src/Emitter.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/Interceptor.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/createRequestId.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/BatchInterceptor.ts","../node_modules/msw/src/browser/setupWorker/start/createStartHandler.ts","../node_modules/msw/src/browser/setupWorker/start/createResponseListener.ts","../node_modules/msw/src/browser/utils/checkWorkerIntegrity.ts","../node_modules/msw/src/browser/setupWorker/start/utils/validateWorkerScope.ts","../node_modules/msw/src/browser/setupWorker/start/utils/enableMocking.ts","../node_modules/msw/src/browser/setupWorker/stop/utils/printStopMessage.ts","../node_modules/msw/src/browser/setupWorker/stop/createStop.ts","../node_modules/msw/src/browser/setupWorker/start/utils/prepareStartHandler.ts","../node_modules/msw/node_modules/.pnpm/@open-draft+deferred-promise@2.2.0/node_modules/@open-draft/deferred-promise/src/DeferredPromise.ts","../node_modules/msw/node_modules/.pnpm/@open-draft+deferred-promise@2.2.0/node_modules/@open-draft/deferred-promise/src/createDeferredExecutor.ts","../node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/utils/RequestController.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/utils/toInteractiveRequest.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/utils/emitAsync.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/interceptors/fetch/index.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/utils/canParseUrl.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/utils/isPropertyAccessible.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/polyfills/EventPolyfill.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/polyfills/ProgressEventPolyfill.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/createEvent.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/utils/findPropertySource.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/utils/createProxy.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/createResponse.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/XMLHttpRequestController.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/concatArrayBuffer.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/utils/parseJson.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/isDomParserSupportedType.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/index.ts","../node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.26.14/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/XMLHttpRequestProxy.ts","../node_modules/msw/src/browser/setupWorker/start/createFallbackStart.ts","../node_modules/msw/src/browser/setupWorker/start/createFallbackRequestListener.ts","../node_modules/msw/src/browser/utils/supportsReadableStreamTransfer.ts","../node_modules/msw/src/browser/setupWorker/setupWorker.ts","../node_modules/msw/src/browser/setupWorker/stop/createFallbackStop.ts"],"sourcesContent":["export default function _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}","export default function _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}","import assertClassBrand from \"./assertClassBrand.js\";\nexport default function _classPrivateFieldGet2(s, a) {\n  return s.get(assertClassBrand(s, a));\n}","export type AsyncTuple<\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n> =\n  | {\n      error: ErrorType\n      data: null\n    }\n  | { error: null; data: DataType }\n\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * const { error, data } = await until(() => asyncAction())\n */\nexport const until = async <\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n>(\n  promise: () => Promise<DataType>,\n): Promise<AsyncTuple<ErrorType, DataType>> => {\n  try {\n    const data = await promise().catch((error) => {\n      throw error\n    })\n    return { error: null, data }\n  } catch (error) {\n    return { error, data: null }\n  }\n}\n","import {\n  RequestHandler,\n  RequestHandlerExecutionResult,\n} from '../handlers/RequestHandler'\n\nexport interface HandlersExecutionResult {\n  handler: RequestHandler\n  parsedResult?: any\n  response?: Response\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string\n}\n\n/**\n * Executes the list of request handlers against the given request.\n * Returns the execution result object containing any matching request\n * handler and any mocked response it returned.\n */\nexport const executeHandlers = async <Handlers extends Array<RequestHandler>>({\n  request,\n  requestId,\n  handlers,\n  resolutionContext,\n}: {\n  request: Request\n  requestId: string\n  handlers: Handlers\n  resolutionContext?: ResponseResolutionContext\n}): Promise<HandlersExecutionResult | null> => {\n  let matchingHandler: RequestHandler | null = null\n  let result: RequestHandlerExecutionResult<any> | null = null\n\n  for (const handler of handlers) {\n    result = await handler.run({ request, requestId, resolutionContext })\n\n    // If the handler produces some result for this request,\n    // it automatically becomes matching.\n    if (result !== null) {\n      matchingHandler = handler\n    }\n\n    // Stop the lookup if this handler returns a mocked response.\n    // If it doesn't, it will still be considered the last matching\n    // handler until any of them returns a response. This way we can\n    // distinguish between fallthrough handlers without responses\n    // and the lack of a matching handler.\n    if (result?.response) {\n      break\n    }\n  }\n\n  if (matchingHandler) {\n    return {\n      handler: matchingHandler,\n      parsedResult: result?.parsedResult,\n      response: result?.response,\n    }\n  }\n\n  return null\n}\n","import { until } from '@open-draft/until'\nimport { Emitter } from 'strict-event-emitter'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { LifeCycleEventsMap, SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { HandlersExecutionResult, executeHandlers } from './executeHandlers'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { readResponseCookies } from './request/readResponseCookies'\n\nexport interface HandleRequestOptions {\n  /**\n   * `resolutionContext` is not part of the general public api\n   * but is exposed to aid in creating extensions like\n   * `@mswjs/http-middleware`.\n   */\n  resolutionContext?: {\n    /**\n     * A base url to use when resolving relative urls.\n     * @note This is primarily used by the `@mswjs/http-middleware`\n     * to resolve relative urls in the context of the running server\n     */\n    baseUrl?: string\n  }\n\n  /**\n   * Transforms a `MockedResponse` instance returned from a handler\n   * to a response instance supported by the lower tooling (i.e. interceptors).\n   */\n  transformResponse?(response: Response): Response\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: Request): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: Response,\n    handler: RequiredDeep<HandlersExecutionResult>,\n  ): void\n}\n\nexport async function handleRequest(\n  request: Request,\n  requestId: string,\n  handlers: Array<RequestHandler>,\n  options: RequiredDeep<SharedOptions>,\n  emitter: Emitter<LifeCycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions,\n): Promise<Response | undefined> {\n  emitter.emit('request:start', { request, requestId })\n\n  // Perform bypassed requests (i.e. wrapped in \"bypass()\") as-is.\n  if (request.headers.get('x-msw-intention') === 'bypass') {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const lookupResult = await until(() => {\n    return executeHandlers({\n      request,\n      requestId,\n      handlers,\n      resolutionContext: handleRequestOptions?.resolutionContext,\n    })\n  })\n\n  if (lookupResult.error) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', {\n      error: lookupResult.error,\n      request,\n      requestId,\n    })\n    throw lookupResult.error\n  }\n\n  // If the handler lookup returned nothing, no request handler was found\n  // matching this request. Report the request as unhandled.\n  if (!lookupResult.data) {\n    await onUnhandledRequest(request, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', { request, requestId })\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  const { response } = lookupResult.data\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Perform the request as-is when the developer explicitly returned \"req.passthrough()\".\n  // This produces no warning as the request was handled.\n  if (\n    response.status === 302 &&\n    response.headers.get('x-msw-intention') === 'passthrough'\n  ) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the virtual cookie store.\n  readResponseCookies(request, response)\n\n  emitter.emit('request:match', { request, requestId })\n\n  const requiredLookupResult =\n    lookupResult.data as RequiredDeep<HandlersExecutionResult>\n\n  const transformedResponse =\n    handleRequestOptions?.transformResponse?.(response) ||\n    (response as any as Response)\n\n  handleRequestOptions?.onMockedResponse?.(\n    transformedResponse,\n    requiredLookupResult,\n  )\n\n  emitter.emit('request:end', { request, requestId })\n\n  return transformedResponse\n}\n","import { toPublicUrl } from './toPublicUrl'\nimport { devUtils } from '../internal/devUtils'\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: Request,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\nexport async function onUnhandledRequest(\n  request: Request,\n  strategy: UnhandledRequestStrategy = 'warn',\n): Promise<void> {\n  const url = new URL(request.url)\n  const publicUrl = toPublicUrl(url)\n\n  const unhandledRequestMessage = `intercepted a request without a matching request handler:\\n\\n  \\u2022 ${request.method} ${publicUrl}\\n\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\\nRead more: https://mswjs.io/docs/getting-started/mocks`\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', unhandledRequestMessage)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', unhandledRequestMessage)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  /**\n   * @note Ignore \"file://\" requests.\n   * Those often are an implementation detail of modern tooling\n   * that fetches modules via HTTP. Developers don't issue those\n   * requests and so they mustn't be warned about them.\n   */\n  if (url.protocol === 'file:') {\n    return\n  }\n\n  applyStrategy(strategy)\n}\n","import { store } from '@mswjs/cookies'\n\nexport function readResponseCookies(\n  request: Request,\n  response: Response,\n): void {\n  store.add({ ...request, url: request.url.toString() }, response)\n  store.persist()\n}\n","export type DisposableSubscription = () => Promise<void> | void\n\nexport class Disposable {\n  protected subscriptions: Array<DisposableSubscription> = []\n\n  public async dispose() {\n    await Promise.all(this.subscriptions.map((subscription) => subscription()))\n  }\n}\n","import { invariant } from 'outvariant'\nimport { EventMap, Emitter } from 'strict-event-emitter'\nimport {\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n} from './handlers/RequestHandler'\nimport { LifeCycleEventEmitter } from './sharedOptions'\nimport { devUtils } from './utils/internal/devUtils'\nimport { pipeEvents } from './utils/internal/pipeEvents'\nimport { toReadonlyArray } from './utils/internal/toReadonlyArray'\nimport { Disposable } from './utils/internal/Disposable'\n\nexport abstract class HandlersController {\n  abstract prepend(runtimeHandlers: Array<RequestHandler>): void\n  abstract reset(nextHandles: Array<RequestHandler>): void\n  abstract currentHandlers(): Array<RequestHandler>\n}\n\nexport class InMemoryHandlersController implements HandlersController {\n  private handlers: Array<RequestHandler>\n\n  constructor(private initialHandlers: Array<RequestHandler>) {\n    this.handlers = [...initialHandlers]\n  }\n\n  public prepend(runtimeHandles: Array<RequestHandler>): void {\n    this.handlers.unshift(...runtimeHandles)\n  }\n\n  public reset(nextHandlers: Array<RequestHandler>): void {\n    this.handlers =\n      nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers]\n  }\n\n  public currentHandlers(): Array<RequestHandler> {\n    return this.handlers\n  }\n}\n\n/**\n * Generic class for the mock API setup.\n */\nexport abstract class SetupApi<EventsMap extends EventMap> extends Disposable {\n  protected handlersController: HandlersController\n  protected readonly emitter: Emitter<EventsMap>\n  protected readonly publicEmitter: Emitter<EventsMap>\n\n  public readonly events: LifeCycleEventEmitter<EventsMap>\n\n  constructor(...initialHandlers: Array<RequestHandler>) {\n    super()\n\n    invariant(\n      this.validateHandlers(initialHandlers),\n      devUtils.formatMessage(\n        `Failed to apply given request handlers: invalid input. Did you forget to spread the request handlers Array?`,\n      ),\n    )\n\n    this.handlersController = new InMemoryHandlersController(initialHandlers)\n\n    this.emitter = new Emitter<EventsMap>()\n    this.publicEmitter = new Emitter<EventsMap>()\n    pipeEvents(this.emitter, this.publicEmitter)\n\n    this.events = this.createLifeCycleEvents()\n\n    this.subscriptions.push(() => {\n      this.emitter.removeAllListeners()\n      this.publicEmitter.removeAllListeners()\n    })\n  }\n\n  private validateHandlers(handlers: ReadonlyArray<RequestHandler>): boolean {\n    // Guard against incorrect call signature of the setup API.\n    return handlers.every((handler) => !Array.isArray(handler))\n  }\n\n  public use(...runtimeHandlers: Array<RequestHandler>): void {\n    invariant(\n      this.validateHandlers(runtimeHandlers),\n      devUtils.formatMessage(\n        `Failed to call \"use()\" with the given request handlers: invalid input. Did you forget to spread the array of request handlers?`,\n      ),\n    )\n\n    this.handlersController.prepend(runtimeHandlers)\n  }\n\n  public restoreHandlers(): void {\n    this.handlersController.currentHandlers().forEach((handler) => {\n      handler.isUsed = false\n    })\n  }\n\n  public resetHandlers(...nextHandlers: Array<RequestHandler>): void {\n    this.handlersController.reset(nextHandlers)\n  }\n\n  public listHandlers(): ReadonlyArray<\n    RequestHandler<RequestHandlerDefaultInfo, any, any>\n  > {\n    return toReadonlyArray(this.handlersController.currentHandlers())\n  }\n\n  private createLifeCycleEvents(): LifeCycleEventEmitter<EventsMap> {\n    return {\n      on: (...args: any[]) => {\n        return (this.publicEmitter.on as any)(...args)\n      },\n      removeListener: (...args: any[]) => {\n        return (this.publicEmitter.removeListener as any)(...args)\n      },\n      removeAllListeners: (...args: any[]) => {\n        return this.publicEmitter.removeAllListeners(...args)\n      },\n    }\n  }\n}\n","import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Pipes all emitted events from one emitter to another.\n */\nexport function pipeEvents<Events extends EventMap>(\n  source: Emitter<Events>,\n  destination: Emitter<Events>,\n): void {\n  const rawEmit: typeof source.emit & { _isPiped?: boolean } = source.emit\n\n  if (rawEmit._isPiped) {\n    return\n  }\n\n  const sourceEmit: typeof source.emit & { _isPiped?: boolean } =\n    function sourceEmit(this: typeof source, event, ...data) {\n      destination.emit(event, ...data)\n      return rawEmit.call(this, event, ...data)\n    }\n\n  sourceEmit._isPiped = true\n\n  source.emit = sourceEmit\n}\n","/**\n * Creates an immutable copy of the given array.\n */\nexport function toReadonlyArray<T>(source: Array<T>): ReadonlyArray<T> {\n  const clone = [...source] as Array<T>\n  Object.freeze(clone)\n  return clone\n}\n","/**\n * Determines if the given value is an object.\n */\nexport function isObject(value: any): boolean {\n  return value != null && typeof value === 'object' && !Array.isArray(value)\n}\n","import { isObject } from './isObject'\n\n/**\n * Deeply merges two given objects with the right one\n * having a priority during property assignment.\n */\nexport function mergeRight(\n  left: Record<string, any>,\n  right: Record<string, any>,\n) {\n  return Object.entries(right).reduce(\n    (result, [key, rightValue]) => {\n      const leftValue = result[key]\n\n      if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n        result[key] = leftValue.concat(rightValue)\n        return result\n      }\n\n      if (isObject(leftValue) && isObject(rightValue)) {\n        result[key] = mergeRight(leftValue, rightValue)\n        return result\n      }\n\n      result[key] = rightValue\n      return result\n    },\n    Object.assign({}, left),\n  )\n}\n","const POSITIONALS_EXP = /(%?)(%([sdijo]))/g\n\nfunction serializePositional(positional: any, flag: string): any {\n  switch (flag) {\n    // Strings.\n    case 's':\n      return positional\n\n    // Digits.\n    case 'd':\n    case 'i':\n      return Number(positional)\n\n    // JSON.\n    case 'j':\n      return JSON.stringify(positional)\n\n    // Objects.\n    case 'o': {\n      // Preserve stings to prevent extra quotes around them.\n      if (typeof positional === 'string') {\n        return positional\n      }\n\n      const json = JSON.stringify(positional)\n\n      // If the positional isn't serializable, return it as-is.\n      if (json === '{}' || json === '[]' || /^\\[object .+?\\]$/.test(json)) {\n        return positional\n      }\n\n      return json\n    }\n  }\n}\n\nexport function format(message: string, ...positionals: any[]): string {\n  if (positionals.length === 0) {\n    return message\n  }\n\n  let positionalIndex = 0\n  let formattedMessage = message.replace(\n    POSITIONALS_EXP,\n    (match, isEscaped, _, flag) => {\n      const positional = positionals[positionalIndex]\n      const value = serializePositional(positional, flag)\n\n      if (!isEscaped) {\n        positionalIndex++\n        return value\n      }\n\n      return match\n    }\n  )\n\n  // Append unresolved positionals to string as-is.\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(' ')}`\n  }\n\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, '%')\n\n  return formattedMessage\n}\n","import { format } from './format'\n\nconst STACK_FRAMES_TO_IGNORE = 2\n\n/**\n * Remove the \"outvariant\" package trace from the given error.\n * This scopes down the error stack to the relevant parts\n * when used in other applications.\n */\nfunction cleanErrorStack(error: Error): void {\n  if (!error.stack) {\n    return\n  }\n\n  const nextStack = error.stack.split('\\n')\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE)\n  error.stack = nextStack.join('\\n')\n}\n\nexport class InvariantError extends Error {\n  name = 'Invariant Violation'\n\n  constructor(public readonly message: string, ...positionals: any[]) {\n    super(message)\n    this.message = format(message, ...positionals)\n    cleanErrorStack(this)\n  }\n}\n\nexport interface CustomErrorConstructor {\n  new (message: string): Error\n}\n\nexport interface CustomErrorFactory {\n  (message: string): Error\n}\n\nexport type CustomError = CustomErrorConstructor | CustomErrorFactory\n\ntype Invariant = {\n  (\n    predicate: unknown,\n    message: string,\n    ...positionals: any[]\n  ): asserts predicate\n\n  as(\n    ErrorConstructor: CustomError,\n    predicate: unknown,\n    message: string,\n    ...positionals: unknown[]\n  ): asserts predicate\n}\n\nexport const invariant: Invariant = (\n  predicate,\n  message,\n  ...positionals\n): asserts predicate => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals)\n  }\n}\n\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage = positionals.length === 0 ? message : format(message, positionals);\n    let error: Error;\n\n    try {\n      error = Reflect.construct(ErrorConstructor as CustomErrorConstructor, [formatMessage]);\n    } catch(err) {\n      error = (ErrorConstructor as CustomErrorFactory)(formatMessage);\n    }\n\n    throw error\n  }\n}\n","/**\n * Determines if the current process is a Node.js process.\n */\nexport function isNodeProcess(): boolean {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return true\n  }\n\n  if (typeof process !== 'undefined') {\n    // Electron (https://www.electronjs.org/docs/latest/api/process#processtype-readonly)\n    const type = (process as any).type\n    if (type === 'renderer' || type === 'worker') {\n      return false\n    }\n\n\n    return !!(\n      process.versions &&\n      process.versions.node\n    )\n  }\n\n  return false\n}\n","export type AsyncTuple<\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n> =\n  | {\n      error: ErrorType\n      data: null\n    }\n  | { error: null; data: DataType }\n\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * const { error, data } = await until(() => asyncAction())\n */\nexport const until = async <\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n>(\n  promise: () => Promise<DataType>,\n): Promise<AsyncTuple<ErrorType, DataType>> => {\n  try {\n    const data = await promise().catch((error) => {\n      throw error\n    })\n    return { error: null, data }\n  } catch (error) {\n    return { error, data: null }\n  }\n}\n","import { FindWorker } from '../../glossary'\n\n/**\n * Attempts to resolve a Service Worker instance from a given registration,\n * regardless of its state (active, installing, waiting).\n */\nexport function getWorkerByRegistration(\n  registration: ServiceWorkerRegistration,\n  absoluteWorkerUrl: string,\n  findWorker: FindWorker,\n): ServiceWorker | null {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting,\n  ]\n  const relevantStates = allStates.filter((state): state is ServiceWorker => {\n    return state != null\n  })\n  const worker = relevantStates.find((worker) => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl)\n  })\n\n  return worker || null\n}\n","import { until } from '@open-draft/until'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { getAbsoluteWorkerUrl } from '../../../utils/getAbsoluteWorkerUrl'\nimport { getWorkerByRegistration } from './getWorkerByRegistration'\nimport { ServiceWorkerInstanceTuple, FindWorker } from '../../glossary'\n\n/**\n * Returns an active Service Worker instance.\n * When not found, registers a new Service Worker.\n */\nexport const getWorkerInstance = async (\n  url: string,\n  options: RegistrationOptions = {},\n  findWorker: FindWorker,\n): Promise<ServiceWorkerInstanceTuple> => {\n  // Resolve the absolute Service Worker URL.\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url)\n\n  const mockRegistrations = await navigator.serviceWorker\n    .getRegistrations()\n    .then((registrations) =>\n      registrations.filter((registration) =>\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n      ),\n    )\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    // Reload the page when it has associated workers, but no active controller.\n    // The absence of a controller can mean either:\n    // - page has no Service Worker associated with it\n    // - page has been hard-reloaded and its workers won't be used until the next reload.\n    // Since we've checked that there are registrations associated with this page,\n    // at this point we are sure it's hard reload that falls into this clause.\n    location.reload()\n  }\n\n  const [existingRegistration] = mockRegistrations\n\n  if (existingRegistration) {\n    // When the Service Worker is registered, update it and return the reference.\n    return existingRegistration.update().then(() => {\n      return [\n        getWorkerByRegistration(\n          existingRegistration,\n          absoluteWorkerUrl,\n          findWorker,\n        ),\n        existingRegistration,\n      ]\n    })\n  }\n\n  // When the Service Worker wasn't found, register it anew and return the reference.\n  const registrationResult = await until<Error, ServiceWorkerInstanceTuple>(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options)\n      return [\n        // Compare existing worker registration by its worker URL,\n        // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration,\n      ]\n    },\n  )\n\n  // Handle Service Worker registration errors.\n  if (registrationResult.error) {\n    const isWorkerMissing = registrationResult.error.message.includes('(404)')\n\n    // Produce a custom error message when given a non-existing Service Worker url.\n    // Suggest developers to check their setup.\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || '/', location.href)\n\n      throw new Error(\n        devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`),\n      )\n    }\n\n    // Fallback error message for any other registration errors.\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to register the Service Worker:\\n\\n%s',\n        registrationResult.error.message,\n      ),\n    )\n  }\n\n  return registrationResult.data\n}\n","/**\n * Returns an absolute Service Worker URL based on the given\n * relative URL (known during the registration).\n */\nexport function getAbsoluteWorkerUrl(workerUrl: string): string {\n  return new URL(workerUrl, location.href).href\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\n\nexport interface PrintStartMessageArgs {\n  quiet?: boolean\n  message?: string\n  workerUrl?: string\n  workerScope?: string\n}\n\n/**\n * Prints a worker activation message in the browser's console.\n */\nexport function printStartMessage(args: PrintStartMessageArgs = {}) {\n  if (args.quiet) {\n    return\n  }\n\n  const message = args.message || 'Mocking enabled.'\n\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    'color:orangered;font-weight:bold;',\n  )\n  console.log(\n    '%cDocumentation: %chttps://mswjs.io/docs',\n    'font-weight:bold',\n    'font-weight:normal',\n  )\n  console.log('Found an issue? https://github.com/mswjs/msw/issues')\n\n  if (args.workerUrl) {\n    console.log('Worker script URL:', args.workerUrl)\n  }\n\n  if (args.workerScope) {\n    console.log('Worker scope:', args.workerScope)\n  }\n\n  console.groupEnd()\n}\n","import {\n  StringifiedResponse,\n  ServiceWorkerIncomingEventsMap,\n} from '../../glossary'\n\nexport interface ServiceWorkerMessage<\n  EventType extends keyof ServiceWorkerIncomingEventsMap,\n  EventPayload,\n> {\n  type: EventType\n  payload: EventPayload\n}\n\ninterface WorkerChannelEventsMap {\n  MOCK_RESPONSE: [\n    data: StringifiedResponse,\n    transfer?: [ReadableStream<Uint8Array>],\n  ]\n  PASSTHROUGH: []\n}\n\nexport class WorkerChannel {\n  constructor(private readonly port: MessagePort) {}\n\n  public postMessage<Event extends keyof WorkerChannelEventsMap>(\n    event: Event,\n    ...rest: WorkerChannelEventsMap[Event]\n  ): void {\n    const [data, transfer] = rest\n    this.port.postMessage({ type: event, data }, { transfer })\n  }\n}\n","import type { ServiceWorkerIncomingRequest } from '../setupWorker/glossary'\n\ntype Input = Pick<ServiceWorkerIncomingRequest, 'method' | 'body'>\n\n/**\n * Ensures that an empty GET request body is always represented as `undefined`.\n */\nexport function pruneGetRequestBody(\n  request: Input,\n): ServiceWorkerIncomingRequest['body'] {\n  // Force HEAD/GET request body to always be empty.\n  // The worker reads any request's body as ArrayBuffer,\n  // and you cannot re-construct a GET/HEAD Request\n  // with an ArrayBuffer, even if empty. Also note that\n  // \"request.body\" is always undefined in the worker.\n  if (['HEAD', 'GET'].includes(request.method)) {\n    return undefined\n  }\n\n  return request.body\n}\n","import {\n  StartOptions,\n  SetupWorkerInternalContext,\n  ServiceWorkerIncomingEventsMap,\n} from '../glossary'\nimport {\n  ServiceWorkerMessage,\n  WorkerChannel,\n} from './utils/createMessageChannel'\nimport { parseWorkerRequest } from '../../utils/parseWorkerRequest'\nimport { RequestHandler } from '~/core/handlers/RequestHandler'\nimport { handleRequest } from '~/core/utils/handleRequest'\nimport { RequiredDeep } from '~/core/typeUtils'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { toResponseInit } from '~/core/utils/toResponseInit'\n\nexport const createRequestListener = (\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n) => {\n  return async (\n    event: MessageEvent,\n    message: ServiceWorkerMessage<\n      'REQUEST',\n      ServiceWorkerIncomingEventsMap['REQUEST']\n    >,\n  ) => {\n    const messageChannel = new WorkerChannel(event.ports[0])\n\n    const requestId = message.payload.id\n    const request = parseWorkerRequest(message.payload)\n    const requestCloneForLogs = request.clone()\n\n    // Make this the first requets clone before the\n    // request resolution pipeline even starts.\n    // Store the clone in cache so the first matching\n    // request handler would skip the cloning phase.\n    const requestClone = request.clone()\n    RequestHandler.cache.set(request, requestClone)\n    context.requests.set(requestId, requestClone)\n\n    try {\n      await handleRequest(\n        request,\n        requestId,\n        context.getRequestHandlers(),\n        options,\n        context.emitter,\n        {\n          onPassthroughResponse() {\n            messageChannel.postMessage('PASSTHROUGH')\n          },\n          async onMockedResponse(response, { handler, parsedResult }) {\n            // Clone the mocked response so its body could be read\n            // to buffer to be sent to the worker and also in the\n            // \".log()\" method of the request handler.\n            const responseClone = response.clone()\n            const responseCloneForLogs = response.clone()\n            const responseInit = toResponseInit(response)\n\n            /**\n             * @note Safari doesn't support transferring a \"ReadableStream\".\n             * Check that the browser supports that before sending it to the worker.\n             */\n            if (context.supports.readableStreamTransfer) {\n              const responseStreamOrNull = response.body\n\n              messageChannel.postMessage(\n                'MOCK_RESPONSE',\n                {\n                  ...responseInit,\n                  body: responseStreamOrNull,\n                },\n                responseStreamOrNull ? [responseStreamOrNull] : undefined,\n              )\n            } else {\n              /**\n               * @note If we are here, this means the current environment doesn't\n               * support \"ReadableStream\" as transferable. In that case,\n               * attempt to read the non-empty response body as ArrayBuffer, if it's not empty.\n               * @see https://github.com/mswjs/msw/issues/1827\n               */\n              const responseBufferOrNull =\n                response.body === null\n                  ? null\n                  : await responseClone.arrayBuffer()\n\n              messageChannel.postMessage('MOCK_RESPONSE', {\n                ...responseInit,\n                body: responseBufferOrNull,\n              })\n            }\n\n            if (!options.quiet) {\n              context.emitter.once('response:mocked', () => {\n                handler.log({\n                  request: requestCloneForLogs,\n                  response: responseCloneForLogs,\n                  parsedResult,\n                })\n              })\n            }\n          },\n        },\n      )\n    } catch (error) {\n      if (error instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,\n          request.method,\n          request.url,\n          error.stack ?? error,\n        )\n\n        // Treat all other exceptions in a request handler as unintended,\n        // alerting that there is a problem that needs fixing.\n        messageChannel.postMessage('MOCK_RESPONSE', {\n          status: 500,\n          statusText: 'Request Handler Error',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          }),\n        })\n      }\n    }\n  }\n}\n","import { pruneGetRequestBody } from './pruneGetRequestBody'\nimport type { ServiceWorkerIncomingRequest } from '../setupWorker/glossary'\n\n/**\n * Converts a given request received from the Service Worker\n * into a Fetch `Request` instance.\n */\nexport function parseWorkerRequest(\n  incomingRequest: ServiceWorkerIncomingRequest,\n): Request {\n  return new Request(incomingRequest.url, {\n    ...incomingRequest,\n    body: pruneGetRequestBody(incomingRequest),\n  })\n}\n","export function toResponseInit(response: Response): ResponseInit {\n  return {\n    status: response.status,\n    statusText: response.statusText,\n    headers: Object.fromEntries(response.headers.entries()),\n  }\n}\n","const encoder = new TextEncoder()\n\nexport function encodeBuffer(text: string): Uint8Array {\n  return encoder.encode(text)\n}\n\nexport function decodeBuffer(buffer: ArrayBuffer, encoding?: string): string {\n  const decoder = new TextDecoder(encoding)\n  return decoder.decode(buffer)\n}\n\n/**\n * Create an `ArrayBuffer` from the given `Uint8Array`.\n * Takes the byte offset into account to produce the right buffer\n * in the case when the buffer is bigger than the data view.\n */\nexport function toArrayBuffer(array: Uint8Array): ArrayBuffer {\n  return array.buffer.slice(\n    array.byteOffset,\n    array.byteOffset + array.byteLength\n  )\n}\n","/**\n * Response status codes for responses that cannot have body.\n * @see https://fetch.spec.whatwg.org/#statuses\n */\nexport const RESPONSE_STATUS_CODES_WITHOUT_BODY = new Set([\n  101, 103, 204, 205, 304,\n])\n\n/**\n * Returns a boolean indicating whether the given response status\n * code represents a response that cannot have a body.\n */\nexport function isResponseWithoutBody(status: number): boolean {\n  return RESPONSE_STATUS_CODES_WITHOUT_BODY.has(status)\n}\n","import type { InteractiveRequest } from './utils/toInteractiveRequest'\n\nexport const IS_PATCHED_MODULE: unique symbol = Symbol('isPatchedModule')\n\nexport type RequestCredentials = 'omit' | 'include' | 'same-origin'\n\nexport type HttpRequestEventMap = {\n  request: [\n    args: {\n      request: InteractiveRequest\n      requestId: string\n    }\n  ]\n  response: [\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ]\n}\n","var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/index.ts\nimport { isNodeProcess } from \"is-node-process\";\nimport { format } from \"outvariant\";\n\n// src/colors.ts\nvar colors_exports = {};\n__export(colors_exports, {\n  blue: () => blue,\n  gray: () => gray,\n  green: () => green,\n  red: () => red,\n  yellow: () => yellow\n});\nfunction yellow(text) {\n  return `\\x1B[33m${text}\\x1B[0m`;\n}\nfunction blue(text) {\n  return `\\x1B[34m${text}\\x1B[0m`;\n}\nfunction gray(text) {\n  return `\\x1B[90m${text}\\x1B[0m`;\n}\nfunction red(text) {\n  return `\\x1B[31m${text}\\x1B[0m`;\n}\nfunction green(text) {\n  return `\\x1B[32m${text}\\x1B[0m`;\n}\n\n// src/index.ts\nvar IS_NODE = isNodeProcess();\nvar Logger = class {\n  constructor(name) {\n    this.name = name;\n    this.prefix = `[${this.name}]`;\n    const LOGGER_NAME = getVariable(\"DEBUG\");\n    const LOGGER_LEVEL = getVariable(\"LOG_LEVEL\");\n    const isLoggingEnabled = LOGGER_NAME === \"1\" || LOGGER_NAME === \"true\" || typeof LOGGER_NAME !== \"undefined\" && this.name.startsWith(LOGGER_NAME);\n    if (isLoggingEnabled) {\n      this.debug = isDefinedAndNotEquals(LOGGER_LEVEL, \"debug\") ? noop : this.debug;\n      this.info = isDefinedAndNotEquals(LOGGER_LEVEL, \"info\") ? noop : this.info;\n      this.success = isDefinedAndNotEquals(LOGGER_LEVEL, \"success\") ? noop : this.success;\n      this.warning = isDefinedAndNotEquals(LOGGER_LEVEL, \"warning\") ? noop : this.warning;\n      this.error = isDefinedAndNotEquals(LOGGER_LEVEL, \"error\") ? noop : this.error;\n    } else {\n      this.info = noop;\n      this.success = noop;\n      this.warning = noop;\n      this.error = noop;\n      this.only = noop;\n    }\n  }\n  prefix;\n  extend(domain) {\n    return new Logger(`${this.name}:${domain}`);\n  }\n  /**\n   * Print a debug message.\n   * @example\n   * logger.debug('no duplicates found, creating a document...')\n   */\n  debug(message, ...positionals) {\n    this.logEntry({\n      level: \"debug\",\n      message: gray(message),\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"gray\"\n      }\n    });\n  }\n  /**\n   * Print an info message.\n   * @example\n   * logger.info('start parsing...')\n   */\n  info(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"blue\"\n      }\n    });\n    const performance2 = new PerformanceEntry();\n    return (message2, ...positionals2) => {\n      performance2.measure();\n      this.logEntry({\n        level: \"info\",\n        message: `${message2} ${gray(`${performance2.deltaTime}ms`)}`,\n        positionals: positionals2,\n        prefix: this.prefix,\n        colors: {\n          prefix: \"blue\"\n        }\n      });\n    };\n  }\n  /**\n   * Print a success message.\n   * @example\n   * logger.success('successfully created document')\n   */\n  success(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: `\\u2714 ${this.prefix}`,\n      colors: {\n        timestamp: \"green\",\n        prefix: \"green\"\n      }\n    });\n  }\n  /**\n   * Print a warning.\n   * @example\n   * logger.warning('found legacy document format')\n   */\n  warning(message, ...positionals) {\n    this.logEntry({\n      level: \"warning\",\n      message,\n      positionals,\n      prefix: `\\u26A0 ${this.prefix}`,\n      colors: {\n        timestamp: \"yellow\",\n        prefix: \"yellow\"\n      }\n    });\n  }\n  /**\n   * Print an error message.\n   * @example\n   * logger.error('something went wrong')\n   */\n  error(message, ...positionals) {\n    this.logEntry({\n      level: \"error\",\n      message,\n      positionals,\n      prefix: `\\u2716 ${this.prefix}`,\n      colors: {\n        timestamp: \"red\",\n        prefix: \"red\"\n      }\n    });\n  }\n  /**\n   * Execute the given callback only when the logging is enabled.\n   * This is skipped in its entirety and has no runtime cost otherwise.\n   * This executes regardless of the log level.\n   * @example\n   * logger.only(() => {\n   *   logger.info('additional info')\n   * })\n   */\n  only(callback) {\n    callback();\n  }\n  createEntry(level, message) {\n    return {\n      timestamp: /* @__PURE__ */ new Date(),\n      level,\n      message\n    };\n  }\n  logEntry(args) {\n    const {\n      level,\n      message,\n      prefix,\n      colors: customColors,\n      positionals = []\n    } = args;\n    const entry = this.createEntry(level, message);\n    const timestampColor = customColors?.timestamp || \"gray\";\n    const prefixColor = customColors?.prefix || \"gray\";\n    const colorize = {\n      timestamp: colors_exports[timestampColor],\n      prefix: colors_exports[prefixColor]\n    };\n    const write = this.getWriter(level);\n    write(\n      [colorize.timestamp(this.formatTimestamp(entry.timestamp))].concat(prefix != null ? colorize.prefix(prefix) : []).concat(serializeInput(message)).join(\" \"),\n      ...positionals.map(serializeInput)\n    );\n  }\n  formatTimestamp(timestamp) {\n    return `${timestamp.toLocaleTimeString(\n      \"en-GB\"\n    )}:${timestamp.getMilliseconds()}`;\n  }\n  getWriter(level) {\n    switch (level) {\n      case \"debug\":\n      case \"success\":\n      case \"info\": {\n        return log;\n      }\n      case \"warning\": {\n        return warn;\n      }\n      case \"error\": {\n        return error;\n      }\n    }\n  }\n};\nvar PerformanceEntry = class {\n  startTime;\n  endTime;\n  deltaTime;\n  constructor() {\n    this.startTime = performance.now();\n  }\n  measure() {\n    this.endTime = performance.now();\n    const deltaTime = this.endTime - this.startTime;\n    this.deltaTime = deltaTime.toFixed(2);\n  }\n};\nvar noop = () => void 0;\nfunction log(message, ...positionals) {\n  if (IS_NODE) {\n    process.stdout.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.log(message, ...positionals);\n}\nfunction warn(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.warn(message, ...positionals);\n}\nfunction error(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.error(message, ...positionals);\n}\nfunction getVariable(variableName) {\n  if (IS_NODE) {\n    return process.env[variableName];\n  }\n  return globalThis[variableName]?.toString();\n}\nfunction isDefinedAndNotEquals(value, expected) {\n  return value !== void 0 && value !== expected;\n}\nfunction serializeInput(message) {\n  if (typeof message === \"undefined\") {\n    return \"undefined\";\n  }\n  if (message === null) {\n    return \"null\";\n  }\n  if (typeof message === \"string\") {\n    return message;\n  }\n  if (typeof message === \"object\") {\n    return JSON.stringify(message);\n  }\n  return message.toString();\n}\nexport {\n  Logger\n};\n","import type { Emitter } from './Emitter'\n\nexport class MemoryLeakError extends Error {\n  constructor(\n    public readonly emitter: Emitter<any>,\n    public readonly type: string | number | symbol,\n    public readonly count: number\n  ) {\n    super(\n      `Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`\n    )\n    this.name = 'MaxListenersExceededWarning'\n  }\n}\n","import { MemoryLeakError } from './MemoryLeakError'\n\nexport type EventMap = {\n  [eventName: string]: Array<unknown>\n}\n\nexport type InternalEventNames = 'newListener' | 'removeListener'\n\nexport type InternalListener<Events extends EventMap> = Listener<\n  [eventName: keyof Events, listener: Listener<Array<unknown>>]\n>\n\nexport type Listener<Data extends Array<unknown>> = (...data: Data) => void\n\n/**\n * Node.js-compatible implementation of `EventEmitter`.\n *\n * @example\n * const emitter = new Emitter<{ hello: [string] }>()\n * emitter.on('hello', (name) => console.log(name))\n * emitter.emit('hello', 'John')\n */\nexport class Emitter<Events extends EventMap> {\n  private events: Map<keyof Events, Array<Listener<any>>>\n  private maxListeners: number\n  private hasWarnedAboutPotentialMemoryLeak: boolean\n\n  static defaultMaxListeners = 10\n\n  static listenerCount<Events extends EventMap>(\n    emitter: Emitter<EventMap>,\n    eventName: keyof Events\n  ): number {\n    return emitter.listenerCount<any>(eventName)\n  }\n\n  constructor() {\n    this.events = new Map()\n    this.maxListeners = Emitter.defaultMaxListeners\n    this.hasWarnedAboutPotentialMemoryLeak = false\n  }\n\n  private _emitInternalEvent(\n    internalEventName: InternalEventNames,\n    eventName: keyof Events,\n    listener: Listener<Array<unknown>>\n  ): void {\n    this.emit(\n      internalEventName,\n      // Anything to make TypeScript happy.\n      ...([eventName, listener] as Events['newListener'] &\n        Events['removeListener'])\n    )\n  }\n\n  private _getListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Array<unknown>>> {\n    // Always return a copy of the listeners array\n    // so they are fixed at the time of the \"_getListeners\" call.\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || []\n  }\n\n  private _removeListener<EventName extends keyof Events>(\n    listeners: Array<Listener<Events[EventName]>>,\n    listener: Listener<Events[EventName]>\n  ): Array<Listener<Events[EventName]>> {\n    const index = listeners.indexOf(listener)\n\n    if (index > -1) {\n      listeners.splice(index, 1)\n    }\n\n    return []\n  }\n\n  private _wrapOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): Listener<Events[EventName]> {\n    const onceListener = (...data: Events[keyof Events]) => {\n      this.removeListener(eventName, onceListener)\n\n      /**\n       * @note Return the result of the original listener.\n       * This way this wrapped preserves listeners that are async.\n       */\n      return listener.apply(this, data)\n    }\n\n    // Inherit the name of the original listener.\n    Object.defineProperty(onceListener, 'name', { value: listener.name })\n\n    return onceListener\n  }\n\n  public setMaxListeners(maxListeners: number): this {\n    this.maxListeners = maxListeners\n    return this\n  }\n\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  public getMaxListeners(): number {\n    return this.maxListeners\n  }\n\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  public eventNames(): Array<keyof Events> {\n    return Array.from(this.events.keys())\n  }\n\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  public emit<EventName extends keyof Events>(\n    eventName: EventName,\n    ...data: Events[EventName]\n  ): boolean {\n    const listeners = this._getListeners(eventName)\n    listeners.forEach((listener) => {\n      listener.apply(this, data)\n    })\n\n    return listeners.length > 0\n  }\n\n  public addListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public addListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public addListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: InternalListener<Events> | Listener<Events[any]>\n  ): this {\n    // Emit the `newListener` event before adding the listener.\n    this._emitInternalEvent('newListener', eventName, listener)\n\n    const nextListeners = this._getListeners(eventName).concat(listener)\n    this.events.set(eventName, nextListeners)\n\n    if (\n      this.maxListeners > 0 &&\n      this.listenerCount(eventName) > this.maxListeners &&\n      !this.hasWarnedAboutPotentialMemoryLeak\n    ) {\n      this.hasWarnedAboutPotentialMemoryLeak = true\n\n      const memoryLeakWarning = new MemoryLeakError(\n        this,\n        eventName,\n        this.listenerCount(eventName)\n      )\n      console.warn(memoryLeakWarning)\n    }\n\n    return this\n  }\n\n  public on(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: 'removeListener' | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(eventName, listener)\n  }\n\n  public once(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: InternalEventNames | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public prependListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners)\n      this.events.set(eventName, nextListeners)\n    } else {\n      this.events.set(eventName, listeners.concat(listener))\n    }\n\n    return this\n  }\n\n  public prependOnceListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependOnceListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.prependListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public removeListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public removeListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public removeListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener)\n      this.events.set(eventName, listeners)\n\n      // Emit the `removeListener` event after removing the listener.\n      this._emitInternalEvent('removeListener', eventName, listener)\n    }\n\n    return this\n  }\n\n  public off(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public off<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  public off(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.removeListener(eventName, listener)\n  }\n\n  public removeAllListeners(eventName?: InternalEventNames): this\n  public removeAllListeners<EventName extends keyof Events>(\n    eventName?: EventName\n  ): this\n  public removeAllListeners(\n    eventName?: InternalEventNames | keyof Events\n  ): this {\n    if (eventName) {\n      this.events.delete(eventName)\n    } else {\n      this.events.clear()\n    }\n\n    return this\n  }\n\n  public listeners(eventName: InternalEventNames): Array<Listener<any>>\n  public listeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>>\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  public listeners(eventName: InternalEventNames | keyof Events) {\n    return Array.from(this._getListeners(eventName))\n  }\n\n  public listenerCount(eventName: InternalEventNames): number\n  public listenerCount<EventName extends keyof Events>(\n    eventName: EventName\n  ): number\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  public listenerCount(eventName: InternalEventNames | keyof Events): number {\n    return this._getListeners(eventName).length\n  }\n\n  public rawListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>> {\n    return this.listeners(eventName)\n  }\n}\n","import { Logger } from '@open-draft/logger'\nimport { Emitter, Listener } from 'strict-event-emitter'\n\nexport type InterceptorEventMap = Record<string, any>\nexport type InterceptorSubscription = () => void\n\n/**\n * Request header name to detect when a single request\n * is being handled by nested interceptors (XHR -> ClientRequest).\n * Obscure by design to prevent collisions with user-defined headers.\n * Ideally, come up with the Interceptor-level mechanism for this.\n * @see https://github.com/mswjs/interceptors/issues/378\n */\nexport const INTERNAL_REQUEST_ID_HEADER_NAME =\n  'x-interceptors-internal-request-id'\n\nexport function getGlobalSymbol<V>(symbol: Symbol): V | undefined {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  )\n}\n\nfunction setGlobalSymbol(symbol: Symbol, value: any): void {\n  // @ts-ignore\n  globalThis[symbol] = value\n}\n\nexport function deleteGlobalSymbol(symbol: Symbol): void {\n  // @ts-ignore\n  delete globalThis[symbol]\n}\n\nexport enum InterceptorReadyState {\n  INACTIVE = 'INACTIVE',\n  APPLYING = 'APPLYING',\n  APPLIED = 'APPLIED',\n  DISPOSING = 'DISPOSING',\n  DISPOSED = 'DISPOSED',\n}\n\nexport type ExtractEventNames<Events extends Record<string, any>> =\n  Events extends Record<infer EventName, any> ? EventName : never\n\nexport class Interceptor<Events extends InterceptorEventMap> {\n  protected emitter: Emitter<Events>\n  protected subscriptions: Array<InterceptorSubscription>\n  protected logger: Logger\n\n  public readyState: InterceptorReadyState\n\n  constructor(private readonly symbol: symbol) {\n    this.readyState = InterceptorReadyState.INACTIVE\n\n    this.emitter = new Emitter()\n    this.subscriptions = []\n    this.logger = new Logger(symbol.description!)\n\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0)\n\n    this.logger.info('constructing the interceptor...')\n  }\n\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  protected checkEnvironment(): boolean {\n    return true\n  }\n\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  public apply(): void {\n    const logger = this.logger.extend('apply')\n    logger.info('applying the interceptor...')\n\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      logger.info('intercepted already applied!')\n      return\n    }\n\n    const shouldApply = this.checkEnvironment()\n\n    if (!shouldApply) {\n      logger.info('the interceptor cannot be applied in this environment!')\n      return\n    }\n\n    this.readyState = InterceptorReadyState.APPLYING\n\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    const runningInstance = this.getInstance()\n\n    if (runningInstance) {\n      logger.info('found a running instance, reusing...')\n\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event)\n\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener)\n\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener)\n          logger.info('removed proxied \"%s\" listener!', event)\n        })\n\n        return this\n      }\n\n      this.readyState = InterceptorReadyState.APPLIED\n\n      return\n    }\n\n    logger.info('no running instance found, setting up a new instance...')\n\n    // Setup the interceptor.\n    this.setup()\n\n    // Store the newly applied interceptor instance globally.\n    this.setInstance()\n\n    this.readyState = InterceptorReadyState.APPLIED\n  }\n\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  protected setup(): void {}\n\n  /**\n   * Listen to the interceptor's public events.\n   */\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    const logger = this.logger.extend('on')\n\n    if (\n      this.readyState === InterceptorReadyState.DISPOSING ||\n      this.readyState === InterceptorReadyState.DISPOSED\n    ) {\n      logger.info('cannot listen to events, already disposed!')\n      return this\n    }\n\n    logger.info('adding \"%s\" event listener:', event, listener)\n\n    this.emitter.on(event, listener)\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.once(event, listener)\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.off(event, listener)\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName\n  ): this {\n    this.emitter.removeAllListeners(event)\n    return this\n  }\n\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  public dispose(): void {\n    const logger = this.logger.extend('dispose')\n\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      logger.info('cannot dispose, already disposed!')\n      return\n    }\n\n    logger.info('disposing the interceptor...')\n    this.readyState = InterceptorReadyState.DISPOSING\n\n    if (!this.getInstance()) {\n      logger.info('no interceptors running, skipping dispose...')\n      return\n    }\n\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance()\n\n    logger.info('global symbol deleted:', getGlobalSymbol(this.symbol))\n\n    if (this.subscriptions.length > 0) {\n      logger.info('disposing of %d subscriptions...', this.subscriptions.length)\n\n      for (const dispose of this.subscriptions) {\n        dispose()\n      }\n\n      this.subscriptions = []\n\n      logger.info('disposed of all subscriptions!', this.subscriptions.length)\n    }\n\n    this.emitter.removeAllListeners()\n    logger.info('destroyed the listener!')\n\n    this.readyState = InterceptorReadyState.DISPOSED\n  }\n\n  private getInstance(): this | undefined {\n    const instance = getGlobalSymbol<this>(this.symbol)\n    this.logger.info('retrieved global instance:', instance?.constructor?.name)\n    return instance\n  }\n\n  private setInstance(): void {\n    setGlobalSymbol(this.symbol, this)\n    this.logger.info('set global instance!', this.symbol.description)\n  }\n\n  private clearInstance(): void {\n    deleteGlobalSymbol(this.symbol)\n    this.logger.info('cleared global instance!', this.symbol.description)\n  }\n}\n","/**\n * Generate a random ID string to represent a request.\n * @example\n * createRequestId()\n * // \"f774b6c9c600f\"\n */\nexport function createRequestId(): string {\n  return Math.random().toString(16).slice(2)\n}\n","import { EventMap, Listener } from 'strict-event-emitter'\nimport { Interceptor, ExtractEventNames } from './Interceptor'\n\nexport interface BatchInterceptorOptions<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> {\n  name: string\n  interceptors: InterceptorList\n}\n\nexport type ExtractEventMapType<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> = InterceptorList extends ReadonlyArray<infer InterceptorType>\n  ? InterceptorType extends Interceptor<infer EventMap>\n    ? EventMap\n    : never\n  : never\n\n/**\n * A batch interceptor that exposes a single interface\n * to apply and operate with multiple interceptors at once.\n */\nexport class BatchInterceptor<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>,\n  Events extends EventMap = ExtractEventMapType<InterceptorList>\n> extends Interceptor<Events> {\n  static symbol: symbol\n\n  private interceptors: InterceptorList\n\n  constructor(options: BatchInterceptorOptions<InterceptorList>) {\n    BatchInterceptor.symbol = Symbol(options.name)\n    super(BatchInterceptor.symbol)\n    this.interceptors = options.interceptors\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('applying all %d interceptors...', this.interceptors.length)\n\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name)\n      interceptor.apply()\n\n      logger.info('adding interceptor dispose subscription')\n      this.subscriptions.push(() => interceptor.dispose())\n    }\n  }\n\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    // Instead of adding a listener to the batch interceptor,\n    // propagate the listener to each of the individual interceptors.\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener)\n    }\n\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener)\n    }\n\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener)\n    }\n\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName | undefined\n  ): this {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event)\n    }\n\n    return this\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport { getWorkerInstance } from './utils/getWorkerInstance'\nimport { enableMocking } from './utils/enableMocking'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { createRequestListener } from './createRequestListener'\nimport { checkWorkerIntegrity } from '../../utils/checkWorkerIntegrity'\nimport { createResponseListener } from './createResponseListener'\nimport { validateWorkerScope } from './utils/validateWorkerScope'\n\nexport const createStartHandler = (\n  context: SetupWorkerInternalContext,\n): StartHandler => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n      context.events.removeAllListeners()\n\n      // Handle requests signaled by the worker.\n      context.workerChannel.on(\n        'REQUEST',\n        createRequestListener(context, options),\n      )\n\n      // Handle responses signaled by the worker.\n      context.workerChannel.on('RESPONSE', createResponseListener(context))\n\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker,\n      )\n\n      const [worker, registration] = instance\n\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker\n          ? devUtils.formatMessage(\n              `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n              options.serviceWorker.url,\n            )\n          : devUtils.formatMessage(\n              `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n              options.serviceWorker.url,\n              location.host,\n            )\n\n        throw new Error(missingWorkerMessage)\n      }\n\n      context.worker = worker\n      context.registration = registration\n\n      context.events.addListener(window, 'beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          context.workerChannel.send('CLIENT_CLOSED')\n        }\n        // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n        window.clearInterval(context.keepAliveInterval)\n      })\n\n      // Check if the active Service Worker has been generated\n      // by the currently installed version of MSW.\n      await checkWorkerIntegrity(context).catch((error) => {\n        devUtils.error(\n          'Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues), including the original error below.',\n        )\n        console.error(error)\n      })\n\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.send('KEEPALIVE_REQUEST'),\n        5000,\n      )\n\n      // Warn the user when loading the page that lies outside\n      // of the worker's scope.\n      validateWorkerScope(registration, context.startOptions)\n\n      return registration\n    }\n\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting\n\n        // Wait until the worker is activated.\n        // Assume the worker is already activated if there's no pending registration\n        // (i.e. when reloading the page after a successful activation).\n        if (pendingInstance) {\n          await new Promise<void>((resolve) => {\n            pendingInstance.addEventListener('statechange', () => {\n              if (pendingInstance.state === 'activated') {\n                return resolve()\n              }\n            })\n          })\n        }\n\n        // Print the activation message only after the worker has been activated.\n        await enableMocking(context, options).catch((error) => {\n          throw new Error(`Failed to enable mocking: ${error?.message}`)\n        })\n\n        return registration\n      },\n    )\n\n    return workerRegistration\n  }\n}\n","import type {\n  ServiceWorkerIncomingEventsMap,\n  SetupWorkerInternalContext,\n} from '../glossary'\nimport type { ServiceWorkerMessage } from './utils/createMessageChannel'\nimport { isResponseWithoutBody } from '@mswjs/interceptors'\n\nexport function createResponseListener(context: SetupWorkerInternalContext) {\n  return (\n    _: MessageEvent,\n    message: ServiceWorkerMessage<\n      'RESPONSE',\n      ServiceWorkerIncomingEventsMap['RESPONSE']\n    >,\n  ) => {\n    const { payload: responseJson } = message\n\n    // Get the Request instance reference stored in the\n    // request listener.\n    const { requestId } = responseJson\n    const request = context.requests.get(requestId)!\n    context.requests.delete(requestId)\n\n    /**\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\n     * That kind of responses cannot be manipulated in JavaScript due\n     * to the security considerations.\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\n     * @see https://github.com/mswjs/msw/issues/529\n     */\n    if (responseJson.type?.includes('opaque')) {\n      return\n    }\n\n    const response =\n      responseJson.status === 0\n        ? Response.error()\n        : new Response(\n            /**\n             * Responses may be streams here, but when we create a response object\n             * with null-body status codes, like 204, 205, 304 Response will\n             * throw when passed a non-null body, so ensure it's null here\n             * for those codes\n             */\n            isResponseWithoutBody(responseJson.status)\n              ? null\n              : responseJson.body,\n            responseJson,\n          )\n\n    /**\n     * Set response URL if it's not set already.\n     * @see https://github.com/mswjs/msw/issues/2030\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Response/url\n     */\n    if (!response.url) {\n      Object.defineProperty(response, 'url', {\n        value: request.url,\n        enumerable: true,\n        writable: false,\n      })\n    }\n\n    context.emitter.emit(\n      responseJson.isMockedResponse ? 'response:mocked' : 'response:bypass',\n      {\n        response,\n        request,\n        requestId: responseJson.requestId,\n      },\n    )\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport type { SetupWorkerInternalContext } from '../setupWorker/glossary'\n\n/**\n * Check whether the registered Service Worker has been\n * generated by the installed version of the library.\n * Prints a warning message if the worker scripts mismatch.\n */\nexport async function checkWorkerIntegrity(\n  context: SetupWorkerInternalContext,\n): Promise<void> {\n  // Request the integrity checksum from the registered worker.\n  context.workerChannel.send('INTEGRITY_CHECK_REQUEST')\n\n  const { payload } = await context.events.once('INTEGRITY_CHECK_RESPONSE')\n\n  // Compare the response from the Service Worker and the\n  // global variable set during the build.\n\n  // The integrity is validated based on the worker script's checksum\n  // that's derived from its minified content during the build.\n  // The \"SERVICE_WORKER_CHECKSUM\" global variable is injected by the build.\n  if (payload.checksum !== SERVICE_WORKER_CHECKSUM) {\n    devUtils.warn(\n      `The currently registered Service Worker has been generated by a different version of MSW (${payload.packageVersion}) and may not be fully compatible with the installed version.\n\nIt's recommended you update your worker script by running this command:\n\n  \\u2022 npx msw init <PUBLIC_DIR>\n\nYou can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`,\n    )\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport { StartOptions } from '../../glossary'\n\nexport function validateWorkerScope(\n  registration: ServiceWorkerRegistration,\n  options?: StartOptions,\n): void {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`,\n    )\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport { StartOptions, SetupWorkerInternalContext } from '../../glossary'\nimport { printStartMessage } from './printStartMessage'\n\n/**\n * Signals the worker to enable the interception of requests.\n */\nexport async function enableMocking(\n  context: SetupWorkerInternalContext,\n  options: StartOptions,\n) {\n  context.workerChannel.send('MOCK_ACTIVATE')\n  await context.events.once('MOCKING_ENABLED')\n\n  // Warn the developer on multiple \"worker.start()\" calls.\n  // While this will not affect the worker in any way,\n  // it likely indicates an issue with the developer's code.\n  if (context.isMockingEnabled) {\n    devUtils.warn(\n      `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`,\n    )\n    return\n  }\n\n  context.isMockingEnabled = true\n\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: context.registration?.scope,\n    workerUrl: context.worker?.scriptURL,\n  })\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\n\nexport function printStopMessage(args: { quiet?: boolean } = {}): void {\n  if (args.quiet) {\n    return\n  }\n\n  console.log(\n    `%c${devUtils.formatMessage('Mocking disabled.')}`,\n    'color:orangered;font-weight:bold;',\n  )\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport const createStop = (\n  context: SetupWorkerInternalContext,\n): StopHandler => {\n  return function stop() {\n    // Warn developers calling \"worker.stop()\" more times than necessary.\n    // This likely indicates a mistake in their code.\n    if (!context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.',\n      )\n      return\n    }\n\n    /**\n     * Signal the Service Worker to disable mocking for this client.\n     * Use this an an explicit way to stop the mocking, while preserving\n     * the worker-client relation. Does not affect the worker's lifecycle.\n     */\n    context.workerChannel.send('MOCK_DEACTIVATE')\n    context.isMockingEnabled = false\n    window.clearInterval(context.keepAliveInterval)\n\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n","import { RequiredDeep } from '~/core/typeUtils'\nimport { mergeRight } from '~/core/utils/internal/mergeRight'\nimport {\n  SetupWorker,\n  SetupWorkerInternalContext,\n  StartHandler,\n  StartOptions,\n} from '../../glossary'\n\nexport const DEFAULT_START_OPTIONS: RequiredDeep<StartOptions> = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null as any,\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'warn',\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl\n  },\n}\n\n/**\n * Returns resolved worker start options, merging the default options\n * with the given custom options.\n */\nexport function resolveStartOptions(\n  initialOptions?: StartOptions,\n): RequiredDeep<StartOptions> {\n  return mergeRight(\n    DEFAULT_START_OPTIONS,\n    initialOptions || {},\n  ) as RequiredDeep<StartOptions>\n}\n\nexport function prepareStartHandler(\n  handler: StartHandler,\n  context: SetupWorkerInternalContext,\n): SetupWorker['start'] {\n  return (initialOptions) => {\n    context.startOptions = resolveStartOptions(initialOptions)\n    return handler(context.startOptions, initialOptions || {})\n  }\n}\n","import {\n  type Executor,\n  type RejectFunction,\n  type ResolveFunction,\n  type DeferredPromiseExecutor,\n  createDeferredExecutor,\n} from './createDeferredExecutor'\n\nexport class DeferredPromise<Input, Output = Input> extends Promise<Input> {\n  #executor: DeferredPromiseExecutor\n\n  public resolve: ResolveFunction<Output>\n  public reject: RejectFunction<Output>\n\n  constructor(executor: Executor<Input> | null = null) {\n    const deferredExecutor = createDeferredExecutor()\n    super((originalResolve, originalReject) => {\n      deferredExecutor(originalResolve, originalReject)\n      executor?.(deferredExecutor.resolve, deferredExecutor.reject)\n    })\n\n    this.#executor = deferredExecutor\n    this.resolve = this.#executor.resolve\n    this.reject = this.#executor.reject\n  }\n\n  public get state() {\n    return this.#executor.state\n  }\n\n  public get rejectionReason() {\n    return this.#executor.rejectionReason\n  }\n\n  public then<ThenResult = Input, CatchResult = never>(\n    onFulfilled?: (value: Input) => ThenResult | PromiseLike<ThenResult>,\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.then(onFulfilled, onRejected))\n  }\n\n  public catch<CatchResult = never>(\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.catch(onRejected))\n  }\n\n  public finally(onfinally?: () => void | Promise<any>) {\n    return this.#decorate(super.finally(onfinally))\n  }\n\n  #decorate<ChildInput>(\n    promise: Promise<ChildInput>\n  ): DeferredPromise<ChildInput, Output> {\n    return Object.defineProperties(promise, {\n      resolve: { configurable: true, value: this.resolve },\n      reject: { configurable: true, value: this.reject },\n    }) as DeferredPromise<ChildInput, Output>\n  }\n}\n","export type PromiseState = 'pending' | 'fulfilled' | 'rejected'\n\nexport type Executor<Value> = ConstructorParameters<typeof Promise<Value>>[0]\nexport type ResolveFunction<Value> = Parameters<Executor<Value>>[0]\nexport type RejectFunction<Reason> = Parameters<Executor<Reason>>[1]\n\nexport type DeferredPromiseExecutor<Input = never, Output = Input> = {\n  (resolve?: ResolveFunction<Input>, reject?: RejectFunction<any>): void\n\n  resolve: ResolveFunction<Input>\n  reject: RejectFunction<any>\n  result?: Output\n  state: PromiseState\n  rejectionReason?: unknown\n}\nexport function createDeferredExecutor<\n  Input = never,\n  Output = Input\n>(): DeferredPromiseExecutor<Input, Output> {\n  const executor = <DeferredPromiseExecutor<Input, Output>>((\n    resolve,\n    reject\n  ) => {\n    executor.state = 'pending'\n\n    executor.resolve = (data) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      executor.result = data as Output\n\n      const onFulfilled = <Value>(value: Value) => {\n        executor.state = 'fulfilled'\n        return value\n      }\n\n      return resolve(\n        data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled)\n      )\n    }\n\n    executor.reject = (reason) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      queueMicrotask(() => {\n        executor.state = 'rejected'\n      })\n\n      return reject((executor.rejectionReason = reason))\n    }\n  })\n\n  return executor\n}\n","import checkPrivateRedeclaration from \"./checkPrivateRedeclaration.js\";\nexport default function _classPrivateMethodInitSpec(obj, privateSet) {\n  checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}","import assertClassBrand from \"./assertClassBrand.js\";\nexport default function _classPrivateFieldSet2(s, a, r) {\n  return s.set(assertClassBrand(s, a), r), r;\n}","import checkPrivateRedeclaration from \"./checkPrivateRedeclaration.js\";\nexport default function _classPrivateFieldInitSpec(obj, privateMap, value) {\n  checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}","import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\n\nexport class RequestController {\n  public responsePromise: DeferredPromise<Response | undefined>\n\n  constructor(protected request: Request) {\n    this.responsePromise = new DeferredPromise()\n  }\n\n  public respondWith(response?: Response): void {\n    invariant(\n      this.responsePromise.state === 'pending',\n      'Failed to respond to \"%s %s\" request: the \"request\" event has already been responded to.',\n      this.request.method,\n      this.request.url\n    )\n\n    this.responsePromise.resolve(response)\n  }\n}\n","import { RequestController } from './RequestController'\n\nexport type InteractiveRequest = globalThis.Request & {\n  respondWith: RequestController['respondWith']\n}\n\nexport function toInteractiveRequest(request: Request): {\n  interactiveRequest: InteractiveRequest\n  requestController: RequestController\n} {\n  const requestController = new RequestController(request)\n\n  Reflect.set(\n    request,\n    'respondWith',\n    requestController.respondWith.bind(requestController)\n  )\n\n  return {\n    interactiveRequest: request as InteractiveRequest,\n    requestController,\n  }\n}\n","import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Emits an event on the given emitter but executes\n * the listeners sequentially. This accounts for asynchronous\n * listeners (e.g. those having \"sleep\" and handling the request).\n */\nexport async function emitAsync<\n  Events extends EventMap,\n  EventName extends keyof Events\n>(\n  emitter: Emitter<Events>,\n  eventName: EventName,\n  ...data: Events[EventName]\n): Promise<void> {\n  const listners = emitter.listeners(eventName)\n\n  if (listners.length === 0) {\n    return\n  }\n\n  for (const listener of listners) {\n    await listener.apply(emitter, data)\n  }\n}\n","import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { until } from '@open-draft/until'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { Interceptor } from '../../Interceptor'\nimport { toInteractiveRequest } from '../../utils/toInteractiveRequest'\nimport { emitAsync } from '../../utils/emitAsync'\nimport { isPropertyAccessible } from '../../utils/isPropertyAccessible'\nimport { canParseUrl } from '../../utils/canParseUrl'\nimport { createRequestId } from '../../createRequestId'\n\nexport class FetchInterceptor extends Interceptor<HttpRequestEventMap> {\n  static symbol = Symbol('fetch')\n\n  constructor() {\n    super(FetchInterceptor.symbol)\n  }\n\n  protected checkEnvironment() {\n    return (\n      typeof globalThis !== 'undefined' &&\n      typeof globalThis.fetch !== 'undefined'\n    )\n  }\n\n  protected async setup() {\n    const pureFetch = globalThis.fetch\n\n    invariant(\n      !(pureFetch as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"fetch\" module: already patched.'\n    )\n\n    globalThis.fetch = async (input, init) => {\n      const requestId = createRequestId()\n\n      /**\n       * @note Resolve potentially relative request URL\n       * against the present `location`. This is mainly\n       * for native `fetch` in JSDOM.\n       * @see https://github.com/mswjs/msw/issues/1625\n       */\n      const resolvedInput =\n        typeof input === 'string' &&\n        typeof location !== 'undefined' &&\n        !canParseUrl(input)\n          ? new URL(input, location.origin)\n          : input\n\n      const request = new Request(resolvedInput, init)\n\n      this.logger.info('[%s] %s', request.method, request.url)\n\n      const { interactiveRequest, requestController } =\n        toInteractiveRequest(request)\n\n      this.logger.info(\n        'emitting the \"request\" event for %d listener(s)...',\n        this.emitter.listenerCount('request')\n      )\n\n      this.emitter.once('request', ({ requestId: pendingRequestId }) => {\n        if (pendingRequestId !== requestId) {\n          return\n        }\n\n        if (requestController.responsePromise.state === 'pending') {\n          requestController.responsePromise.resolve(undefined)\n        }\n      })\n\n      this.logger.info('awaiting for the mocked response...')\n\n      const signal = interactiveRequest.signal\n      const requestAborted = new DeferredPromise()\n\n      // Signal isn't always defined in react-native.\n      if (signal) {\n        signal.addEventListener(\n          'abort',\n          () => {\n            requestAborted.reject(signal.reason)\n          },\n          { once: true }\n        )\n      }\n\n      const resolverResult = await until(async () => {\n        const listenersFinished = emitAsync(this.emitter, 'request', {\n          request: interactiveRequest,\n          requestId,\n        })\n\n        await Promise.race([\n          requestAborted,\n          // Put the listeners invocation Promise in the same race condition\n          // with the request abort Promise because otherwise awaiting the listeners\n          // would always yield some response (or undefined).\n          listenersFinished,\n          requestController.responsePromise,\n        ])\n\n        this.logger.info('all request listeners have been resolved!')\n\n        const mockedResponse = await requestController.responsePromise\n        this.logger.info('event.respondWith called with:', mockedResponse)\n\n        return mockedResponse\n      })\n\n      if (requestAborted.state === 'rejected') {\n        return Promise.reject(requestAborted.rejectionReason)\n      }\n\n      if (resolverResult.error) {\n        return Promise.reject(createNetworkError(resolverResult.error))\n      }\n\n      const mockedResponse = resolverResult.data\n\n      if (mockedResponse && !request.signal?.aborted) {\n        this.logger.info('received mocked response:', mockedResponse)\n\n        // Reject the request Promise on mocked \"Response.error\" responses.\n        if (\n          isPropertyAccessible(mockedResponse, 'type') &&\n          mockedResponse.type === 'error'\n        ) {\n          this.logger.info(\n            'received a network error response, rejecting the request promise...'\n          )\n\n          /**\n           * Set the cause of the request promise rejection to the\n           * network error Response instance. This different from Undici.\n           * Undici will forward the \"response.error\" custom property\n           * as the rejection reason but for \"Response.error()\" static method\n           * \"response.error\" will equal to undefined, making \"cause\" an empty Error.\n           * @see https://github.com/nodejs/undici/blob/83cb522ae0157a19d149d72c7d03d46e34510d0a/lib/fetch/response.js#L344\n           */\n          return Promise.reject(createNetworkError(mockedResponse))\n        }\n\n        // Clone the mocked response for the \"response\" event listener.\n        // This way, the listener can read the response and not lock its body\n        // for the actual fetch consumer.\n        const responseClone = mockedResponse.clone()\n\n        this.emitter.emit('response', {\n          response: responseClone,\n          isMockedResponse: true,\n          request: interactiveRequest,\n          requestId,\n        })\n\n        // Set the \"response.url\" property to equal the intercepted request URL.\n        Object.defineProperty(mockedResponse, 'url', {\n          writable: false,\n          enumerable: true,\n          configurable: false,\n          value: request.url,\n        })\n\n        return mockedResponse\n      }\n\n      this.logger.info('no mocked response received!')\n\n      return pureFetch(request).then((response) => {\n        const responseClone = response.clone()\n        this.logger.info('original fetch performed', responseClone)\n\n        this.emitter.emit('response', {\n          response: responseClone,\n          isMockedResponse: false,\n          request: interactiveRequest,\n          requestId,\n        })\n\n        return response\n      })\n    }\n\n    Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.fetch = pureFetch\n\n      this.logger.info(\n        'restored native \"globalThis.fetch\"!',\n        globalThis.fetch.name\n      )\n    })\n  }\n}\n\nfunction createNetworkError(cause: unknown) {\n  return Object.assign(new TypeError('Failed to fetch'), {\n    cause,\n  })\n}\n","/**\n * Returns a boolean indicating whether the given URL string\n * can be parsed into a `URL` instance.\n * A substitute for `URL.canParse()` for Node.js 18.\n */\nexport function canParseUrl(url: string): boolean {\n  try {\n    new URL(url)\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n","/**\n * A function that validates if property access is possible on an object\n * without throwing. It returns `true` if the property access is possible\n * and `false` otherwise.\n *\n * Environments like miniflare will throw on property access on certain objects\n * like Request and Response, for unimplemented properties.\n */\nexport function isPropertyAccessible<Obj extends Record<string, any>>(\n  obj: Obj,\n  key: keyof Obj\n) {\n  try {\n    obj[key]\n    return true\n  } catch {\n    return false\n  }\n}\n","export class EventPolyfill implements Event {\n  readonly AT_TARGET: number = 0\n  readonly BUBBLING_PHASE: number = 0\n  readonly CAPTURING_PHASE: number = 0\n  readonly NONE: number = 0\n\n  public type: string = ''\n  public srcElement: EventTarget | null = null\n  public target: EventTarget | null\n  public currentTarget: EventTarget | null = null\n  public eventPhase: number = 0\n  public timeStamp: number\n  public isTrusted: boolean = true\n  public composed: boolean = false\n  public cancelable: boolean = true\n  public defaultPrevented: boolean = false\n  public bubbles: boolean = true\n  public lengthComputable: boolean = true\n  public loaded: number = 0\n  public total: number = 0\n\n  cancelBubble: boolean = false\n  returnValue: boolean = true\n\n  constructor(\n    type: string,\n    options?: { target: EventTarget; currentTarget: EventTarget }\n  ) {\n    this.type = type\n    this.target = options?.target || null\n    this.currentTarget = options?.currentTarget || null\n    this.timeStamp = Date.now()\n  }\n\n  public composedPath(): EventTarget[] {\n    return []\n  }\n\n  public initEvent(type: string, bubbles?: boolean, cancelable?: boolean) {\n    this.type = type\n    this.bubbles = !!bubbles\n    this.cancelable = !!cancelable\n  }\n\n  public preventDefault() {\n    this.defaultPrevented = true\n  }\n\n  public stopPropagation() {}\n  public stopImmediatePropagation() {}\n}\n","import { EventPolyfill } from './EventPolyfill'\n\nexport class ProgressEventPolyfill extends EventPolyfill {\n  readonly lengthComputable: boolean\n  readonly composed: boolean\n  readonly loaded: number\n  readonly total: number\n\n  constructor(type: string, init?: ProgressEventInit) {\n    super(type)\n\n    this.lengthComputable = init?.lengthComputable || false\n    this.composed = init?.composed || false\n    this.loaded = init?.loaded || 0\n    this.total = init?.total || 0\n  }\n}\n","import { EventPolyfill } from '../polyfills/EventPolyfill'\nimport { ProgressEventPolyfill } from '../polyfills/ProgressEventPolyfill'\n\nconst SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== 'undefined'\n\nexport function createEvent(\n  target: XMLHttpRequest,\n  type: string,\n  init?: ProgressEventInit\n): EventPolyfill {\n  const progressEvents = [\n    'error',\n    'progress',\n    'loadstart',\n    'loadend',\n    'load',\n    'timeout',\n    'abort',\n  ]\n\n  /**\n   * `ProgressEvent` is not supported in React Native.\n   * @see https://github.com/mswjs/interceptors/issues/40\n   */\n  const ProgressEventClass = SUPPORTS_PROGRESS_EVENT\n    ? ProgressEvent\n    : ProgressEventPolyfill\n\n  const event = progressEvents.includes(type)\n    ? new ProgressEventClass(type, {\n        lengthComputable: true,\n        loaded: init?.loaded || 0,\n        total: init?.total || 0,\n      })\n    : new EventPolyfill(type, {\n        target,\n        currentTarget: target,\n      })\n\n  return event\n}\n","/**\n * Returns the source object of the given property on the target object\n * (the target itself, any parent in its prototype, or null).\n */\nexport function findPropertySource(\n  target: object,\n  propertyName: string | symbol\n): object | null {\n  if (!(propertyName in target)) {\n    return null\n  }\n\n  const hasProperty = Object.prototype.hasOwnProperty.call(target, propertyName)\n  if (hasProperty) {\n    return target\n  }\n\n  const prototype = Reflect.getPrototypeOf(target)\n  return prototype ? findPropertySource(prototype, propertyName) : null\n}\n","import { findPropertySource } from './findPropertySource'\n\nexport interface ProxyOptions<Target extends Record<string, any>> {\n  constructorCall?(args: Array<unknown>, next: NextFunction<Target>): Target\n\n  methodCall?<F extends keyof Target>(\n    this: Target,\n    data: [methodName: F, args: Array<unknown>],\n    next: NextFunction<void>\n  ): void\n\n  setProperty?(\n    data: [propertyName: string | symbol, nextValue: unknown],\n    next: NextFunction<boolean>\n  ): boolean\n\n  getProperty?(\n    data: [propertyName: string | symbol, receiver: Target],\n    next: NextFunction<void>\n  ): void\n}\n\nexport type NextFunction<ReturnType> = () => ReturnType\n\nexport function createProxy<Target extends object>(\n  target: Target,\n  options: ProxyOptions<Target>\n): Target {\n  const proxy = new Proxy(target, optionsToProxyHandler(options))\n\n  return proxy\n}\n\nfunction optionsToProxyHandler<T extends Record<string, any>>(\n  options: ProxyOptions<T>\n): ProxyHandler<T> {\n  const { constructorCall, methodCall, getProperty, setProperty } = options\n  const handler: ProxyHandler<T> = {}\n\n  if (typeof constructorCall !== 'undefined') {\n    handler.construct = function (target, args, newTarget) {\n      const next = Reflect.construct.bind(null, target as any, args, newTarget)\n      return constructorCall.call(newTarget, args, next)\n    }\n  }\n\n  handler.set = function (target, propertyName, nextValue) {\n    const next = () => {\n      const propertySource = findPropertySource(target, propertyName) || target\n      const ownDescriptors = Reflect.getOwnPropertyDescriptor(\n        propertySource,\n        propertyName\n      )\n\n      // Respect any custom setters present for this property.\n      if (typeof ownDescriptors?.set !== 'undefined') {\n        ownDescriptors.set.apply(target, [nextValue])\n        return true\n      }\n\n      // Otherwise, set the property on the source.\n      return Reflect.defineProperty(propertySource, propertyName, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: nextValue,\n      })\n    }\n\n    if (typeof setProperty !== 'undefined') {\n      return setProperty.call(target, [propertyName, nextValue], next)\n    }\n\n    return next()\n  }\n\n  handler.get = function (target, propertyName, receiver) {\n    /**\n     * @note Using `Reflect.get()` here causes \"TypeError: Illegal invocation\".\n     */\n    const next = () => target[propertyName as any]\n\n    const value =\n      typeof getProperty !== 'undefined'\n        ? getProperty.call(target, [propertyName, receiver], next)\n        : next()\n\n    if (typeof value === 'function') {\n      return (...args: Array<any>) => {\n        const next = value.bind(target, ...args)\n\n        if (typeof methodCall !== 'undefined') {\n          return methodCall.call(target, [propertyName as any, args], next)\n        }\n\n        return next()\n      }\n    }\n\n    return value\n  }\n\n  return handler\n}\n","import { isResponseWithoutBody } from '../../../utils/responseUtils'\n\n/**\n * Creates a Fetch API `Response` instance from the given\n * `XMLHttpRequest` instance and a response body.\n */\nexport function createResponse(\n  request: XMLHttpRequest,\n  body: BodyInit | null\n): Response {\n  /**\n   * Handle XMLHttpRequest responses that must have null as the\n   * response body when represented using Fetch API Response.\n   * XMLHttpRequest response will always have an empty string\n   * as the \"request.response\" in those cases, resulting in an error\n   * when constructing a Response instance.\n   * @see https://github.com/mswjs/interceptors/issues/379\n   */\n  const responseBodyOrNull = isResponseWithoutBody(request.status) ? null : body\n\n  return new Response(responseBodyOrNull, {\n    status: request.status,\n    statusText: request.statusText,\n    headers: createHeadersFromXMLHttpReqestHeaders(\n      request.getAllResponseHeaders()\n    ),\n  })\n}\n\nfunction createHeadersFromXMLHttpReqestHeaders(headersString: string): Headers {\n  const headers = new Headers()\n\n  const lines = headersString.split(/[\\r\\n]+/)\n  for (const line of lines) {\n    if (line.trim() === '') {\n      continue\n    }\n\n    const [name, ...parts] = line.split(': ')\n    const value = parts.join(': ')\n\n    headers.append(name, value)\n  }\n\n  return headers\n}\n","import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport type { Logger } from '@open-draft/logger'\nimport { concatArrayBuffer } from './utils/concatArrayBuffer'\nimport { createEvent } from './utils/createEvent'\nimport {\n  decodeBuffer,\n  encodeBuffer,\n  toArrayBuffer,\n} from '../../utils/bufferUtils'\nimport { createProxy } from '../../utils/createProxy'\nimport { isDomParserSupportedType } from './utils/isDomParserSupportedType'\nimport { parseJson } from '../../utils/parseJson'\nimport { createResponse } from './utils/createResponse'\nimport { INTERNAL_REQUEST_ID_HEADER_NAME } from '../../Interceptor'\nimport { createRequestId } from '../../createRequestId'\n\nconst IS_MOCKED_RESPONSE = Symbol('isMockedResponse')\nconst IS_NODE = isNodeProcess()\n\n/**\n * An `XMLHttpRequest` instance controller that allows us\n * to handle any given request instance (e.g. responding to it).\n */\nexport class XMLHttpRequestController {\n  public request: XMLHttpRequest\n  public requestId: string\n  public onRequest?: (\n    this: XMLHttpRequestController,\n    args: {\n      request: Request\n      requestId: string\n    }\n  ) => Promise<void>\n  public onResponse?: (\n    this: XMLHttpRequestController,\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ) => void\n\n  private method: string = 'GET'\n  private url: URL = null as any\n  private requestHeaders: Headers\n  private requestBody?: XMLHttpRequestBodyInit | Document | null\n  private responseBuffer: Uint8Array\n  private events: Map<keyof XMLHttpRequestEventTargetEventMap, Array<Function>>\n\n  constructor(\n    readonly initialRequest: XMLHttpRequest,\n    public logger: Logger\n  ) {\n    this.events = new Map()\n    this.requestId = createRequestId()\n    this.requestHeaders = new Headers()\n    this.responseBuffer = new Uint8Array()\n\n    this.request = createProxy(initialRequest, {\n      setProperty: ([propertyName, nextValue], invoke) => {\n        switch (propertyName) {\n          case 'ontimeout': {\n            const eventName = propertyName.slice(\n              2\n            ) as keyof XMLHttpRequestEventTargetEventMap\n\n            /**\n             * @note Proxy callbacks to event listeners because JSDOM has trouble\n             * translating these properties to callbacks. It seemed to be operating\n             * on events exclusively.\n             */\n            this.request.addEventListener(eventName, nextValue as any)\n\n            return invoke()\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n      methodCall: ([methodName, args], invoke) => {\n        switch (methodName) {\n          case 'open': {\n            const [method, url] = args as [string, string | undefined]\n\n            if (typeof url === 'undefined') {\n              this.method = 'GET'\n              this.url = toAbsoluteUrl(method)\n            } else {\n              this.method = method\n              this.url = toAbsoluteUrl(url)\n            }\n\n            this.logger = this.logger.extend(`${this.method} ${this.url.href}`)\n            this.logger.info('open', this.method, this.url.href)\n\n            return invoke()\n          }\n\n          case 'addEventListener': {\n            const [eventName, listener] = args as [\n              keyof XMLHttpRequestEventTargetEventMap,\n              Function,\n            ]\n\n            this.registerEvent(eventName, listener)\n            this.logger.info('addEventListener', eventName, listener)\n\n            return invoke()\n          }\n\n          case 'setRequestHeader': {\n            const [name, value] = args as [string, string]\n            this.requestHeaders.set(name, value)\n\n            this.logger.info('setRequestHeader', name, value)\n\n            return invoke()\n          }\n\n          case 'send': {\n            const [body] = args as [\n              body?: XMLHttpRequestBodyInit | Document | null,\n            ]\n\n            if (body != null) {\n              this.requestBody =\n                typeof body === 'string' ? encodeBuffer(body) : body\n            }\n\n            this.request.addEventListener('load', () => {\n              if (typeof this.onResponse !== 'undefined') {\n                // Create a Fetch API Response representation of whichever\n                // response this XMLHttpRequest received. Note those may\n                // be either a mocked and the original response.\n                const fetchResponse = createResponse(\n                  this.request,\n                  /**\n                   * The `response` property is the right way to read\n                   * the ambiguous response body, as the request's \"responseType\" may differ.\n                   * @see https://xhr.spec.whatwg.org/#the-response-attribute\n                   */\n                  this.request.response\n                )\n\n                // Notify the consumer about the response.\n                this.onResponse.call(this, {\n                  response: fetchResponse,\n                  isMockedResponse: IS_MOCKED_RESPONSE in this.request,\n                  request: fetchRequest,\n                  requestId: this.requestId!,\n                })\n              }\n            })\n\n            // Delegate request handling to the consumer.\n            const fetchRequest = this.toFetchApiRequest()\n            const onceRequestSettled =\n              this.onRequest?.call(this, {\n                request: fetchRequest,\n                requestId: this.requestId!,\n              }) || Promise.resolve()\n\n            onceRequestSettled.finally(() => {\n              // If the consumer didn't handle the request perform it as-is.\n              // Note that the request may not yet be DONE and may, in fact,\n              // be LOADING while the \"respondWith\" method does its magic.\n              if (this.request.readyState < this.request.LOADING) {\n                this.logger.info(\n                  'request callback settled but request has not been handled (readystate %d), performing as-is...',\n                  this.request.readyState\n                )\n\n                /**\n                 * @note Set the intercepted request ID on the original request in Node.js\n                 * so that if it triggers any other interceptors, they don't attempt\n                 * to process it once again.\n                 *\n                 * For instance, XMLHttpRequest is often implemented via \"http.ClientRequest\"\n                 * and we don't want for both XHR and ClientRequest interceptors to\n                 * handle the same request at the same time (e.g. emit the \"response\" event twice).\n                 */\n                if (IS_NODE) {\n                  this.request.setRequestHeader(\n                    INTERNAL_REQUEST_ID_HEADER_NAME,\n                    this.requestId!\n                  )\n                }\n\n                return invoke()\n              }\n            })\n\n            break\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n    })\n  }\n\n  private registerEvent(\n    eventName: keyof XMLHttpRequestEventTargetEventMap,\n    listener: Function\n  ): void {\n    const prevEvents = this.events.get(eventName) || []\n    const nextEvents = prevEvents.concat(listener)\n    this.events.set(eventName, nextEvents)\n\n    this.logger.info('registered event \"%s\"', eventName, listener)\n  }\n\n  /**\n   * Responds to the current request with the given\n   * Fetch API `Response` instance.\n   */\n  public respondWith(response: Response): void {\n    this.logger.info(\n      'responding with a mocked response: %d %s',\n      response.status,\n      response.statusText\n    )\n\n    /**\n     * @note Since `XMLHttpRequestController` delegates the handling of the responses\n     * to the \"load\" event listener that doesn't distinguish between the mocked and original\n     * responses, mark the request that had a mocked response with a corresponding symbol.\n     */\n    define(this.request, IS_MOCKED_RESPONSE, true)\n\n    define(this.request, 'status', response.status)\n    define(this.request, 'statusText', response.statusText)\n    define(this.request, 'responseURL', this.url.href)\n\n    this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, {\n      apply: (_, __, args: [name: string]) => {\n        this.logger.info('getResponseHeader', args[0])\n\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info('headers not received yet, returning null')\n\n          // Headers not received yet, nothing to return.\n          return null\n        }\n\n        const headerValue = response.headers.get(args[0])\n        this.logger.info(\n          'resolved response header \"%s\" to',\n          args[0],\n          headerValue\n        )\n\n        return headerValue\n      },\n    })\n\n    this.request.getAllResponseHeaders = new Proxy(\n      this.request.getAllResponseHeaders,\n      {\n        apply: () => {\n          this.logger.info('getAllResponseHeaders')\n\n          if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n            this.logger.info('headers not received yet, returning empty string')\n\n            // Headers not received yet, nothing to return.\n            return ''\n          }\n\n          const headersList = Array.from(response.headers.entries())\n          const allHeaders = headersList\n            .map(([headerName, headerValue]) => {\n              return `${headerName}: ${headerValue}`\n            })\n            .join('\\r\\n')\n\n          this.logger.info('resolved all response headers to', allHeaders)\n\n          return allHeaders\n        },\n      }\n    )\n\n    // Update the response getters to resolve against the mocked response.\n    Object.defineProperties(this.request, {\n      response: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.response,\n      },\n      responseText: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseText,\n      },\n      responseXML: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseXML,\n      },\n    })\n\n    const totalResponseBodyLength = response.headers.has('Content-Length')\n      ? Number(response.headers.get('Content-Length'))\n      : /**\n         * @todo Infer the response body length from the response body.\n         */\n        undefined\n\n    this.logger.info('calculated response body length', totalResponseBodyLength)\n\n    this.trigger('loadstart', {\n      loaded: 0,\n      total: totalResponseBodyLength,\n    })\n\n    this.setReadyState(this.request.HEADERS_RECEIVED)\n    this.setReadyState(this.request.LOADING)\n\n    const finalizeResponse = () => {\n      this.logger.info('finalizing the mocked response...')\n\n      this.setReadyState(this.request.DONE)\n\n      this.trigger('load', {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n\n      this.trigger('loadend', {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n    }\n\n    if (response.body) {\n      this.logger.info('mocked response has body, streaming...')\n\n      const reader = response.body.getReader()\n\n      const readNextResponseBodyChunk = async () => {\n        const { value, done } = await reader.read()\n\n        if (done) {\n          this.logger.info('response body stream done!')\n          finalizeResponse()\n          return\n        }\n\n        if (value) {\n          this.logger.info('read response body chunk:', value)\n          this.responseBuffer = concatArrayBuffer(this.responseBuffer, value)\n\n          this.trigger('progress', {\n            loaded: this.responseBuffer.byteLength,\n            total: totalResponseBodyLength,\n          })\n        }\n\n        readNextResponseBodyChunk()\n      }\n\n      readNextResponseBodyChunk()\n    } else {\n      finalizeResponse()\n    }\n  }\n\n  private responseBufferToText(): string {\n    return decodeBuffer(this.responseBuffer)\n  }\n\n  get response(): unknown {\n    this.logger.info(\n      'getResponse (responseType: %s)',\n      this.request.responseType\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    switch (this.request.responseType) {\n      case 'json': {\n        const responseJson = parseJson(this.responseBufferToText())\n        this.logger.info('resolved response JSON', responseJson)\n\n        return responseJson\n      }\n\n      case 'arraybuffer': {\n        const arrayBuffer = toArrayBuffer(this.responseBuffer)\n        this.logger.info('resolved response ArrayBuffer', arrayBuffer)\n\n        return arrayBuffer\n      }\n\n      case 'blob': {\n        const mimeType =\n          this.request.getResponseHeader('Content-Type') || 'text/plain'\n        const responseBlob = new Blob([this.responseBufferToText()], {\n          type: mimeType,\n        })\n\n        this.logger.info(\n          'resolved response Blob (mime type: %s)',\n          responseBlob,\n          mimeType\n        )\n\n        return responseBlob\n      }\n\n      default: {\n        const responseText = this.responseBufferToText()\n        this.logger.info(\n          'resolving \"%s\" response type as text',\n          this.request.responseType,\n          responseText\n        )\n\n        return responseText\n      }\n    }\n  }\n\n  get responseText(): string {\n    /**\n     * Throw when trying to read the response body as text when the\n     * \"responseType\" doesn't expect text. This just respects the spec better.\n     * @see https://xhr.spec.whatwg.org/#the-responsetext-attribute\n     */\n    invariant(\n      this.request.responseType === '' || this.request.responseType === 'text',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (\n      this.request.readyState !== this.request.LOADING &&\n      this.request.readyState !== this.request.DONE\n    ) {\n      return ''\n    }\n\n    const responseText = this.responseBufferToText()\n    this.logger.info('getResponseText: \"%s\"', responseText)\n\n    return responseText\n  }\n\n  get responseXML(): Document | null {\n    invariant(\n      this.request.responseType === '' ||\n        this.request.responseType === 'document',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    const contentType = this.request.getResponseHeader('Content-Type') || ''\n\n    if (typeof DOMParser === 'undefined') {\n      console.warn(\n        'Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly.'\n      )\n      return null\n    }\n\n    if (isDomParserSupportedType(contentType)) {\n      return new DOMParser().parseFromString(\n        this.responseBufferToText(),\n        contentType\n      )\n    }\n\n    return null\n  }\n\n  public errorWith(error: Error): void {\n    this.logger.info('responding with an error')\n\n    this.setReadyState(this.request.DONE)\n    this.trigger('error')\n    this.trigger('loadend')\n  }\n\n  /**\n   * Transitions this request's `readyState` to the given one.\n   */\n  private setReadyState(nextReadyState: number): void {\n    this.logger.info(\n      'setReadyState: %d -> %d',\n      this.request.readyState,\n      nextReadyState\n    )\n\n    if (this.request.readyState === nextReadyState) {\n      this.logger.info('ready state identical, skipping transition...')\n      return\n    }\n\n    define(this.request, 'readyState', nextReadyState)\n\n    this.logger.info('set readyState to: %d', nextReadyState)\n\n    if (nextReadyState !== this.request.UNSENT) {\n      this.logger.info('triggerring \"readystatechange\" event...')\n\n      this.trigger('readystatechange')\n    }\n  }\n\n  /**\n   * Triggers given event on the `XMLHttpRequest` instance.\n   */\n  private trigger<\n    EventName extends keyof (XMLHttpRequestEventTargetEventMap & {\n      readystatechange: ProgressEvent<XMLHttpRequestEventTarget>\n    }),\n  >(eventName: EventName, options?: ProgressEventInit): void {\n    const callback = this.request[`on${eventName}`]\n    const event = createEvent(this.request, eventName, options)\n\n    this.logger.info('trigger \"%s\"', eventName, options || '')\n\n    // Invoke direct callbacks.\n    if (typeof callback === 'function') {\n      this.logger.info('found a direct \"%s\" callback, calling...', eventName)\n      callback.call(this.request, event)\n    }\n\n    // Invoke event listeners.\n    for (const [registeredEventName, listeners] of this.events) {\n      if (registeredEventName === eventName) {\n        this.logger.info(\n          'found %d listener(s) for \"%s\" event, calling...',\n          listeners.length,\n          eventName\n        )\n\n        listeners.forEach((listener) => listener.call(this.request, event))\n      }\n    }\n  }\n\n  /**\n   * Converts this `XMLHttpRequest` instance into a Fetch API `Request` instance.\n   */\n  public toFetchApiRequest(): Request {\n    this.logger.info('converting request to a Fetch API Request...')\n\n    const fetchRequest = new Request(this.url.href, {\n      method: this.method,\n      headers: this.requestHeaders,\n      /**\n       * @see https://xhr.spec.whatwg.org/#cross-origin-credentials\n       */\n      credentials: this.request.withCredentials ? 'include' : 'same-origin',\n      body: ['GET', 'HEAD'].includes(this.method)\n        ? null\n        : (this.requestBody as BodyInit),\n    })\n\n    const proxyHeaders = createProxy(fetchRequest.headers, {\n      methodCall: ([methodName, args], invoke) => {\n        // Forward the latest state of the internal request headers\n        // because the interceptor might have modified them\n        // without responding to the request.\n        switch (methodName) {\n          case 'append':\n          case 'set': {\n            const [headerName, headerValue] = args as [string, string]\n            this.request.setRequestHeader(headerName, headerValue)\n            break\n          }\n\n          case 'delete': {\n            const [headerName] = args as [string]\n            console.warn(\n              `XMLHttpRequest: Cannot remove a \"${headerName}\" header from the Fetch API representation of the \"${fetchRequest.method} ${fetchRequest.url}\" request. XMLHttpRequest headers cannot be removed.`\n            )\n            break\n          }\n        }\n\n        return invoke()\n      },\n    })\n    define(fetchRequest, 'headers', proxyHeaders)\n\n    this.logger.info('converted request to a Fetch API Request!', fetchRequest)\n\n    return fetchRequest\n  }\n}\n\nfunction toAbsoluteUrl(url: string | URL): URL {\n  /**\n   * @note XMLHttpRequest interceptor may run in environments\n   * that implement XMLHttpRequest but don't implement \"location\"\n   * (for example, React Native). If that's the case, return the\n   * input URL as-is (nothing to be relative to).\n   * @see https://github.com/mswjs/msw/issues/1777\n   */\n  if (typeof location === 'undefined') {\n    return new URL(url)\n  }\n\n  return new URL(url.toString(), location.href)\n}\n\nfunction define(\n  target: object,\n  property: string | symbol,\n  value: unknown\n): void {\n  Reflect.defineProperty(target, property, {\n    // Ensure writable properties to allow redefining readonly properties.\n    writable: true,\n    enumerable: true,\n    value,\n  })\n}\n","/**\n * Concatenate two `Uint8Array` buffers.\n */\nexport function concatArrayBuffer(\n  left: Uint8Array,\n  right: Uint8Array\n): Uint8Array {\n  const result = new Uint8Array(left.byteLength + right.byteLength)\n  result.set(left, 0)\n  result.set(right, left.byteLength)\n  return result\n}\n","/**\n * Parses a given string into JSON.\n * Gracefully handles invalid JSON by returning `null`.\n */\nexport function parseJson(data: string): Record<string, unknown> | null {\n  try {\n    const json = JSON.parse(data)\n    return json\n  } catch (_) {\n    return null\n  }\n}\n","export function isDomParserSupportedType(\n  type: string\n): type is DOMParserSupportedType {\n  const supportedTypes: Array<DOMParserSupportedType> = [\n    'application/xhtml+xml',\n    'application/xml',\n    'image/svg+xml',\n    'text/html',\n    'text/xml',\n  ]\n  return supportedTypes.some((supportedType) => {\n    return type.startsWith(supportedType)\n  })\n}\n","import { invariant } from 'outvariant'\nimport { Emitter } from 'strict-event-emitter'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { InteractiveRequest } from '../../utils/toInteractiveRequest'\nimport { Interceptor } from '../../Interceptor'\nimport { createXMLHttpRequestProxy } from './XMLHttpRequestProxy'\n\nexport type XMLHttpRequestEventListener = (args: {\n  request: InteractiveRequest\n  requestId: string\n}) => Promise<void> | void\n\nexport type XMLHttpRequestEmitter = Emitter<HttpRequestEventMap>\n\nexport class XMLHttpRequestInterceptor extends Interceptor<HttpRequestEventMap> {\n  static interceptorSymbol = Symbol('xhr')\n\n  constructor() {\n    super(XMLHttpRequestInterceptor.interceptorSymbol)\n  }\n\n  protected checkEnvironment() {\n    return typeof globalThis.XMLHttpRequest !== 'undefined'\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('patching \"XMLHttpRequest\" module...')\n\n    const PureXMLHttpRequest = globalThis.XMLHttpRequest\n\n    invariant(\n      !(PureXMLHttpRequest as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"XMLHttpRequest\" module: already patched.'\n    )\n\n    globalThis.XMLHttpRequest = createXMLHttpRequestProxy({\n      emitter: this.emitter,\n      logger: this.logger,\n    })\n\n    logger.info(\n      'native \"XMLHttpRequest\" module patched!',\n      globalThis.XMLHttpRequest.name\n    )\n\n    Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.XMLHttpRequest = PureXMLHttpRequest\n      logger.info(\n        'native \"XMLHttpRequest\" module restored!',\n        globalThis.XMLHttpRequest.name\n      )\n    })\n  }\n}\n","import { until } from '@open-draft/until'\nimport type { Logger } from '@open-draft/logger'\nimport { XMLHttpRequestEmitter } from '.'\nimport { toInteractiveRequest } from '../../utils/toInteractiveRequest'\nimport { emitAsync } from '../../utils/emitAsync'\nimport { XMLHttpRequestController } from './XMLHttpRequestController'\n\nexport interface XMLHttpRequestProxyOptions {\n  emitter: XMLHttpRequestEmitter\n  logger: Logger\n}\n\n/**\n * Create a proxied `XMLHttpRequest` class.\n * The proxied class establishes spies on certain methods,\n * allowing us to intercept requests and respond to them.\n */\nexport function createXMLHttpRequestProxy({\n  emitter,\n  logger,\n}: XMLHttpRequestProxyOptions) {\n  const XMLHttpRequestProxy = new Proxy(globalThis.XMLHttpRequest, {\n    construct(target, args, newTarget) {\n      logger.info('constructed new XMLHttpRequest')\n\n      const originalRequest = Reflect.construct(\n        target,\n        args,\n        newTarget\n      ) as XMLHttpRequest\n\n      /**\n       * @note Forward prototype descriptors onto the proxied object.\n       * XMLHttpRequest is implemented in JSDOM in a way that assigns\n       * a bunch of descriptors, like \"set responseType()\" on the prototype.\n       * With this propagation, we make sure that those descriptors trigger\n       * when the user operates with the proxied request instance.\n       */\n      const prototypeDescriptors = Object.getOwnPropertyDescriptors(\n        target.prototype\n      )\n      for (const propertyName in prototypeDescriptors) {\n        Reflect.defineProperty(\n          originalRequest,\n          propertyName,\n          prototypeDescriptors[propertyName]\n        )\n      }\n\n      const xhrRequestController = new XMLHttpRequestController(\n        originalRequest,\n        logger\n      )\n\n      xhrRequestController.onRequest = async function ({ request, requestId }) {\n        const { interactiveRequest, requestController } =\n          toInteractiveRequest(request)\n\n        this.logger.info('awaiting mocked response...')\n\n        emitter.once('request', ({ requestId: pendingRequestId }) => {\n          if (pendingRequestId !== requestId) {\n            return\n          }\n\n          if (requestController.responsePromise.state === 'pending') {\n            requestController.respondWith(undefined)\n          }\n        })\n\n        const resolverResult = await until(async () => {\n          this.logger.info(\n            'emitting the \"request\" event for %s listener(s)...',\n            emitter.listenerCount('request')\n          )\n\n          await emitAsync(emitter, 'request', {\n            request: interactiveRequest,\n            requestId,\n          })\n\n          this.logger.info('all \"request\" listeners settled!')\n\n          const mockedResponse = await requestController.responsePromise\n\n          this.logger.info('event.respondWith called with:', mockedResponse)\n\n          return mockedResponse\n        })\n\n        if (resolverResult.error) {\n          this.logger.info(\n            'request listener threw an exception, aborting request...',\n            resolverResult.error\n          )\n\n          /**\n           * @todo Consider forwarding this error to the stderr as well\n           * since not all consumers are expecting to handle errors.\n           * If they don't, this error will be swallowed.\n           */\n          xhrRequestController.errorWith(resolverResult.error)\n          return\n        }\n\n        const mockedResponse = resolverResult.data\n\n        if (typeof mockedResponse !== 'undefined') {\n          this.logger.info(\n            'received mocked response: %d %s',\n            mockedResponse.status,\n            mockedResponse.statusText\n          )\n\n          if (mockedResponse.type === 'error') {\n            this.logger.info(\n              'received a network error response, rejecting the request promise...'\n            )\n\n            xhrRequestController.errorWith(new TypeError('Network error'))\n            return\n          }\n\n          return xhrRequestController.respondWith(mockedResponse)\n        }\n\n        this.logger.info(\n          'no mocked response received, performing request as-is...'\n        )\n      }\n\n      xhrRequestController.onResponse = async function ({\n        response,\n        isMockedResponse,\n        request,\n        requestId,\n      }) {\n        this.logger.info(\n          'emitting the \"response\" event for %s listener(s)...',\n          emitter.listenerCount('response')\n        )\n\n        emitter.emit('response', {\n          response,\n          isMockedResponse,\n          request,\n          requestId,\n        })\n      }\n\n      // Return the proxied request from the controller\n      // so that the controller can react to the consumer's interactions\n      // with this request (opening/sending/etc).\n      return xhrRequestController.request\n    },\n  })\n\n  return XMLHttpRequestProxy\n}\n","import { createFallbackRequestListener } from './createFallbackRequestListener'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { printStartMessage } from './utils/printStartMessage'\n\nexport function createFallbackStart(\n  context: SetupWorkerInternalContext,\n): StartHandler {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(\n      context,\n      options,\n    )\n\n    printStartMessage({\n      message: 'Mocking enabled (fallback mode).',\n      quiet: options.quiet,\n    })\n\n    return undefined\n  }\n}\n","import {\n  Interceptor,\n  BatchInterceptor,\n  HttpRequestEventMap,\n} from '@mswjs/interceptors'\nimport { FetchInterceptor } from '@mswjs/interceptors/fetch'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/XMLHttpRequest'\nimport { SetupWorkerInternalContext, StartOptions } from '../glossary'\nimport type { RequiredDeep } from '~/core/typeUtils'\nimport { handleRequest } from '~/core/utils/handleRequest'\n\nexport function createFallbackRequestListener(\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Interceptor<HttpRequestEventMap> {\n  const interceptor = new BatchInterceptor({\n    name: 'fallback',\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()],\n  })\n\n  interceptor.on('request', async ({ request, requestId }) => {\n    const requestCloneForLogs = request.clone()\n\n    const response = await handleRequest(\n      request,\n      requestId,\n      context.getRequestHandlers(),\n      options,\n      context.emitter,\n      {\n        onMockedResponse(_, { handler, parsedResult }) {\n          if (!options.quiet) {\n            context.emitter.once('response:mocked', ({ response }) => {\n              handler.log({\n                request: requestCloneForLogs,\n                response,\n                parsedResult,\n              })\n            })\n          }\n        },\n      },\n    )\n\n    if (response) {\n      request.respondWith(response)\n    }\n  })\n\n  interceptor.on(\n    'response',\n    ({ response, isMockedResponse, request, requestId }) => {\n      context.emitter.emit(\n        isMockedResponse ? 'response:mocked' : 'response:bypass',\n        {\n          response,\n          request,\n          requestId,\n        },\n      )\n    },\n  )\n\n  interceptor.apply()\n\n  return interceptor\n}\n","/**\n * Returns a boolean indicating whether the current browser\n * supports `ReadableStream` as a `Transferable` when posting\n * messages.\n */\nexport function supportsReadableStreamTransfer() {\n  try {\n    const stream = new ReadableStream({\n      start: (controller) => controller.close(),\n    })\n    const message = new MessageChannel()\n    message.port1.postMessage(stream, [stream])\n    return true\n  } catch (error) {\n    return false\n  }\n}\n","import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport {\n  SetupWorkerInternalContext,\n  ServiceWorkerIncomingEventsMap,\n  StartReturnType,\n  StopHandler,\n  StartHandler,\n  StartOptions,\n} from './glossary'\nimport { createStartHandler } from './start/createStartHandler'\nimport { createStop } from './stop/createStop'\nimport { ServiceWorkerMessage } from './start/utils/createMessageChannel'\nimport { RequestHandler } from '~/core/handlers/RequestHandler'\nimport { DEFAULT_START_OPTIONS } from './start/utils/prepareStartHandler'\nimport { createFallbackStart } from './start/createFallbackStart'\nimport { createFallbackStop } from './stop/createFallbackStop'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { SetupApi } from '~/core/SetupApi'\nimport { mergeRight } from '~/core/utils/internal/mergeRight'\nimport { LifeCycleEventsMap } from '~/core/sharedOptions'\nimport { SetupWorker } from './glossary'\nimport { supportsReadableStreamTransfer } from '../utils/supportsReadableStreamTransfer'\n\ninterface Listener {\n  target: EventTarget\n  eventType: string\n  callback: EventListenerOrEventListenerObject\n}\n\nexport class SetupWorkerApi\n  extends SetupApi<LifeCycleEventsMap>\n  implements SetupWorker\n{\n  private context: SetupWorkerInternalContext\n  private startHandler: StartHandler = null as any\n  private stopHandler: StopHandler = null as any\n  private listeners: Array<Listener>\n\n  constructor(...handlers: Array<RequestHandler>) {\n    super(...handlers)\n\n    invariant(\n      !isNodeProcess(),\n      devUtils.formatMessage(\n        'Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.',\n      ),\n    )\n\n    this.listeners = []\n    this.context = this.createWorkerContext()\n  }\n\n  private createWorkerContext(): SetupWorkerInternalContext {\n    const context: SetupWorkerInternalContext = {\n      // Mocking is not considered enabled until the worker\n      // signals back the successful activation event.\n      isMockingEnabled: false,\n      startOptions: null as any,\n      worker: null,\n      getRequestHandlers: () => {\n        return this.handlersController.currentHandlers()\n      },\n      registration: null,\n      requests: new Map(),\n      emitter: this.emitter,\n      workerChannel: {\n        on: (eventType, callback) => {\n          this.context.events.addListener<\n            MessageEvent<ServiceWorkerMessage<typeof eventType, any>>\n          >(navigator.serviceWorker, 'message', (event) => {\n            // Avoid messages broadcasted from unrelated workers.\n            if (event.source !== this.context.worker) {\n              return\n            }\n\n            const message = event.data\n\n            if (!message) {\n              return\n            }\n\n            if (message.type === eventType) {\n              callback(event, message)\n            }\n          })\n        },\n        send: (type) => {\n          this.context.worker?.postMessage(type)\n        },\n      },\n      events: {\n        addListener: (target, eventType, callback) => {\n          target.addEventListener(eventType, callback as EventListener)\n          this.listeners.push({\n            eventType,\n            target,\n            callback: callback as EventListener,\n          })\n\n          return () => {\n            target.removeEventListener(eventType, callback as EventListener)\n          }\n        },\n        removeAllListeners: () => {\n          for (const { target, eventType, callback } of this.listeners) {\n            target.removeEventListener(eventType, callback)\n          }\n          this.listeners = []\n        },\n        once: (eventType) => {\n          const bindings: Array<() => void> = []\n\n          return new Promise<\n            ServiceWorkerMessage<\n              typeof eventType,\n              ServiceWorkerIncomingEventsMap[typeof eventType]\n            >\n          >((resolve, reject) => {\n            const handleIncomingMessage = (event: MessageEvent) => {\n              try {\n                const message = event.data\n\n                if (message.type === eventType) {\n                  resolve(message)\n                }\n              } catch (error) {\n                reject(error)\n              }\n            }\n\n            bindings.push(\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                'message',\n                handleIncomingMessage,\n              ),\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                'messageerror',\n                reject,\n              ),\n            )\n          }).finally(() => {\n            bindings.forEach((unbind) => unbind())\n          })\n        },\n      },\n      supports: {\n        serviceWorkerApi:\n          !('serviceWorker' in navigator) || location.protocol === 'file:',\n        readableStreamTransfer: supportsReadableStreamTransfer(),\n      },\n    }\n\n    this.startHandler = context.supports.serviceWorkerApi\n      ? createFallbackStart(context)\n      : createStartHandler(context)\n\n    this.stopHandler = context.supports.serviceWorkerApi\n      ? createFallbackStop(context)\n      : createStop(context)\n\n    return context\n  }\n\n  public async start(options: StartOptions = {}): StartReturnType {\n    if (options.waitUntilReady === true) {\n      devUtils.warn(\n        'The \"waitUntilReady\" option has been deprecated. Please remove it from this \"worker.start()\" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.',\n      )\n    }\n\n    this.context.startOptions = mergeRight(\n      DEFAULT_START_OPTIONS,\n      options,\n    ) as SetupWorkerInternalContext['startOptions']\n\n    return await this.startHandler(this.context.startOptions, options)\n  }\n\n  public stop(): void {\n    super.dispose()\n    this.context.events.removeAllListeners()\n    this.context.emitter.removeAllListeners()\n    this.stopHandler()\n  }\n}\n\n/**\n * Sets up a requests interception in the browser with the given request handlers.\n * @param {RequestHandler[]} handlers List of request handlers.\n *\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker()` API reference}\n */\nexport function setupWorker(...handlers: Array<RequestHandler>): SetupWorker {\n  return new SetupWorkerApi(...handlers)\n}\n","import { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport function createFallbackStop(\n  context: SetupWorkerInternalContext,\n): StopHandler {\n  return function stop() {\n    context.fallbackInterceptor?.dispose()\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n"],"names":["_checkPrivateRedeclaration","obj","privateCollection","has","TypeError","_assertClassBrand","e","t","n","arguments","length","_classPrivateFieldGet2","s","a","get","until","async","data","promise","catch","error","executeHandlers","request","requestId","handlers","resolutionContext","_ref","matchingHandler","result","handler","_result","run","response","_result2","_result3","parsedResult","handleRequest","options","emitter","handleRequestOptions","_handleRequestOptions5","_handleRequestOptions6","_handleRequestOptions","emit","headers","onPassthroughResponse","call","lookupResult","_handleRequestOptions2","strategy","undefined","url","URL","publicUrl","toPublicUrl","unhandledRequestMessage","concat","method","applyStrategy","strategy2","devUtils","Error","formatMessage","warn","protocol","warning","bind","onUnhandledRequest","_handleRequestOptions3","_handleRequestOptions4","status","store","add","toString","persist","readResponseCookies","requiredLookupResult","transformedResponse","transformResponse","onMockedResponse","Disposable","constructor","_defineProperty","dispose","Promise","all","this","subscriptions","map","subscription","InMemoryHandlersController","initialHandlers","prepend","runtimeHandles","unshift","reset","nextHandlers","currentHandlers","SetupApi","super","_len","Array","_key","invariant","validateHandlers","handlersController","Emitter","publicEmitter","source","destination","rawEmit","_isPiped","sourceEmit","event","pipeEvents","events","createLifeCycleEvents","push","removeAllListeners","every","isArray","use","_len2","runtimeHandlers","_key2","restoreHandlers","forEach","isUsed","resetHandlers","_len3","_key3","listHandlers","clone","Object","freeze","toReadonlyArray","_this","on","removeListener","isObject","value","mergeRight","left","right","entries","reduce","key","rightValue","leftValue","assign","POSITIONALS_EXP","format","message","positionals","positionalIndex","formattedMessage","replace","match","isEscaped","_","flag","positional","Number","JSON","stringify","json","test","serializePositional","slice","join","InvariantError","name","error2","stack","nextStack","split","splice","cleanErrorStack","predicate","isNodeProcess","navigator","product","process","type","versions","node","as","ErrorConstructor","_len4","_key4","Reflect","construct","err","getWorkerByRegistration","registration","absoluteWorkerUrl","findWorker","active","installing","waiting","filter","state","find","worker2","scriptURL","getWorkerInstance","location","href","mockRegistrations","serviceWorker","getRegistrations","then","registrations","controller","reload","existingRegistration","update","registrationResult","register","includes","scopeUrl","scope","printStartMessage","args","quiet","console","groupCollapsed","devUtils2","log","workerUrl","workerScope","groupEnd","WorkerChannel","port","postMessage","_len5","rest","_key5","transfer","pruneGetRequestBody","body","createRequestListener","context","messageChannel","ports","payload","id","incomingRequest","Request","requestCloneForLogs","requestClone","RequestHandler","cache","set","requests","getRequestHandlers","responseClone","responseCloneForLogs","responseInit","statusText","fromEntries","toResponseInit","supports","readableStreamTransfer","responseStreamOrNull","responseBufferOrNull","arrayBuffer","once","_error2$stack","devUtils4","encoder","TextEncoder","RESPONSE_STATUS_CODES_WITHOUT_BODY","Set","isResponseWithoutBody","IS_PATCHED_MODULE","Symbol","__defProp","defineProperty","colors_exports","yellow","text","blue","gray","red","green","__export","target","enumerable","IS_NODE","Logger","prefix","LOGGER_NAME","getVariable","LOGGER_LEVEL","startsWith","debug","isDefinedAndNotEquals","noop","info","success","only","extend","domain","_len6","_key6","logEntry","level","colors","_len7","_key7","performance2","PerformanceEntry","message2","measure","_len8","positionals2","_key8","deltaTime","_len9","_key9","timestamp","_len10","_key10","_len11","_key11","callback","createEntry","Date","customColors","entry","timestampColor","prefixColor","colorize","getWriter","write","formatTimestamp","serializeInput","toLocaleTimeString","getMilliseconds","startTime","performance","now","endTime","toFixed","_len12","_key12","stdout","_len13","_key13","stderr","_len14","_key14","variableName","_globalThis$variableN","globalThis","expected","MemoryLeakError","count","_Emitter","listenerCount","eventName","Map","maxListeners","defaultMaxListeners","hasWarnedAboutPotentialMemoryLeak","_emitInternalEvent","internalEventName","listener","_getListeners","prototype","apply","_removeListener","listeners","index","indexOf","_wrapOnceListener","_this2","onceListener","_len15","_key15","setMaxListeners","getMaxListeners","eventNames","from","keys","_len16","_key16","addListener","nextListeners","memoryLeakWarning","prependListener","prependOnceListener","off","delete","clear","rawListeners","getGlobalSymbol","symbol","Interceptor","readyState","logger","description","checkEnvironment","runningInstance","getInstance","setup","setInstance","clearInstance","_a","instance","createRequestId","Math","random","BatchInterceptor","interceptors","interceptor","createStartHandler","customOptions","workerRegistration","workerChannel","_responseJson$type","responseJson","Response","writable","isMockedResponse","createResponseListener","worker","missingWorkerMessage","devUtils7","host","window","send","clearInterval","keepAliveInterval","checksum","devUtils5","packageVersion","checkWorkerIntegrity","setInterval","devUtils6","validateWorkerScope","startOptions","startWorkerInstance","pendingInstance","resolve","addEventListener","_context$registration","_context$worker","isMockingEnabled","devUtils3","enableMocking","printStopMessage","devUtils8","DEFAULT_START_OPTIONS","waitUntilReady","mockServiceWorkerUrl","DeferredPromise","_executor","WeakMap","_Class3_brand","WeakSet","executor","deferredExecutor","reject","reason","queueMicrotask","rejectionReason","createDeferredExecutor","privateSet","r","originalResolve","originalReject","privateMap","_classPrivateFieldInitSpec","_classPrivateFieldGet","onFulfilled","onRejected","_decorate","finally","onfinally","defineProperties","configurable","RequestController","responsePromise","respondWith","toInteractiveRequest","requestController","interactiveRequest","emitAsync","listners","_len17","_key17","_FetchInterceptor","fetch","pureFetch","input","init","resolvedInput","_error","canParseUrl","origin","_ref2","pendingRequestId","signal","requestAborted","resolverResult","listenersFinished","race","mockedResponse2","createNetworkError","mockedResponse","aborted","isPropertyAccessible","FetchInterceptor","cause","EventPolyfill","AT_TARGET","BUBBLING_PHASE","CAPTURING_PHASE","NONE","srcElement","currentTarget","eventPhase","isTrusted","composed","cancelable","defaultPrevented","bubbles","lengthComputable","loaded","total","cancelBubble","returnValue","timeStamp","composedPath","initEvent","preventDefault","stopPropagation","stopImmediatePropagation","ProgressEventPolyfill","SUPPORTS_PROGRESS_EVENT","ProgressEvent","findPropertySource","propertyName","hasOwnProperty","getPrototypeOf","createProxy","proxy","Proxy","constructorCall","methodCall","getProperty","setProperty","newTarget","next","nextValue","propertySource","ownDescriptors","getOwnPropertyDescriptor","receiver","_len18","_key18","next2","optionsToProxyHandler","createHeadersFromXMLHttpReqestHeaders","headersString","Headers","lines","line","trim","parts","append","IS_MOCKED_RESPONSE","IS_NODE2","XMLHttpRequestController","initialRequest","requestHeaders","responseBuffer","Uint8Array","_ref3","invoke","_ref4","methodName","toAbsoluteUrl","registerEvent","requestBody","encode","onResponse","fetchResponse","responseBodyOrNull","getAllResponseHeaders","createResponse","fetchRequest","toFetchApiRequest","onRequest","LOADING","setRequestHeader","nextEvents","define","getResponseHeader","__","HEADERS_RECEIVED","headerValue","allHeaders","_ref5","headerName","responseText","responseXML","totalResponseBodyLength","trigger","setReadyState","finalizeResponse","DONE","byteLength","reader","getReader","readNextResponseBodyChunk","done","read","concatArrayBuffer","responseBufferToText","buffer","TextDecoder","encoding","decode","responseType","parse","parseJson","array","byteOffset","mimeType","responseBlob","Blob","contentType","DOMParser","some","supportedType","parseFromString","errorWith","nextReadyState","UNSENT","ProgressEventClass","createEvent","registeredEventName","credentials","withCredentials","proxyHeaders","_ref6","property","_XMLHttpRequestInterceptor","interceptorSymbol","XMLHttpRequest","PureXMLHttpRequest","_ref7","originalRequest","prototypeDescriptors","getOwnPropertyDescriptors","xhrRequestController","_ref8","_ref9","_ref10","createXMLHttpRequestProxy","XMLHttpRequestInterceptor","createFallbackStart","fallbackInterceptor","_ref11","handleRequest2","_ref12","_ref13","response2","_ref14","createFallbackRequestListener","supportsReadableStreamTransfer","stream","ReadableStream","start","close","MessageChannel","port1","SetupWorkerApi","devUtils10","createWorkerContext","eventType","_this$context$worker","removeEventListener","bindings","unbind","serviceWorkerApi","startHandler","stopHandler","_context$fallbackInte","_context$startOptions2","createFallbackStop","_context$startOptions","devUtils9","createStop","mergeRight2","stop","setupWorker","_len19","_key19"],"sourceRoot":""}